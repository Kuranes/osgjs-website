<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title></title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/jsoverson/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>osg/Texture.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"></i></a></h2>
      <p class="stat">69.42</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h2>
      <p class="stat">420</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty"></i></a></h2>
      <p class="stat">53.02</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs"></i></a></h2>
      <p class="stat">4.18</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">define( [
    &#039;Q&#039;,
    &#039;osg/Notify&#039;,
    &#039;osg/Utils&#039;,
    &#039;osg/StateAttribute&#039;,
    &#039;osg/Uniform&#039;,
    &#039;osg/Image&#039;,
    &#039;osg/ShaderGenerator&#039;,
    &#039;osgDB/ReaderParser&#039;
], function ( Q, Notify, MACROUTILS, StateAttribute, Uniform, Image, ShaderGenerator, ReaderParser ) {

    // helper
    var isPowerOf2 = function ( x ) {
        /*jshint bitwise: false */
        return ( ( x !== 0 ) &amp;&amp; ( ( x &amp; ( ~x + 1 ) ) === x ) );
        /*jshint bitwise: true */
    };


    /**
     * Texture encapsulate webgl texture object
     * @class Texture
     * @inherits StateAttribute
     */
    var Texture = function () {
        StateAttribute.call( this );
        this.setDefaultParameters();
        this._applyTexImage2DCallbacks = [];
    };
    Texture.DEPTH_COMPONENT = 0x1902;
    Texture.ALPHA = 0x1906;
    Texture.RGB = 0x1907;
    Texture.RGBA = 0x1908;
    Texture.LUMINANCE = 0x1909;
    Texture.LUMINANCE_ALPHA = 0x190A;

    // filter mode
    Texture.LINEAR = 0x2601;
    Texture.NEAREST = 0x2600;
    Texture.NEAREST_MIPMAP_NEAREST = 0x2700;
    Texture.LINEAR_MIPMAP_NEAREST = 0x2701;
    Texture.NEAREST_MIPMAP_LINEAR = 0x2702;
    Texture.LINEAR_MIPMAP_LINEAR = 0x2703;

    // wrap mode
    Texture.CLAMP_TO_EDGE = 0x812F;
    Texture.REPEAT = 0x2901;
    Texture.MIRRORED_REPEAT = 0x8370;

    // target
    Texture.TEXTURE_2D = 0x0DE1;
    Texture.TEXTURE_CUBE_MAP = 0x8513;
    Texture.TEXTURE_BINDING_CUBE_MAP = 0x8514;
    Texture.TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
    Texture.TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;
    Texture.TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;
    Texture.TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;
    Texture.TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;
    Texture.TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;
    Texture.MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;

    Texture.UNSIGNED_BYTE = 0x1401;
    Texture.FLOAT = 0x1406;


    /** @lends Texture.prototype */
    Texture.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInehrit( StateAttribute.prototype, {
        attributeType: &#039;Texture&#039;,
        cloneType: function () {
            var t = new Texture();
            t.defaultType = true;
            return t;
        },
        getType: function () {
            return this.attributeType;
        },
        getTypeMember: function () {
            return this.attributeType;
        },
        getOrCreateUniforms: function ( unit ) {
            if ( Texture.uniforms === undefined ) {
                Texture.uniforms = [];
            }
            if ( Texture.uniforms[ unit ] === undefined ) {
                var name = this.getType() + unit;
                var uniforms = {};
                uniforms.texture = Uniform.createInt1( unit, name );
                uniforms.uniformKeys = window.Object.keys( uniforms );
                Texture.uniforms[ unit ] = uniforms;
            }
            // uniform for an texture attribute should directly in Texture.uniforms[unit] and not in Texture.uniforms[unit][Texture0]
            return Texture.uniforms[ unit ];
        },
        setDefaultParameters: function () {
            this._image = undefined;
            this._magFilter = Texture.LINEAR;
            this._minFilter = Texture.LINEAR;
            this._wrapS = Texture.CLAMP_TO_EDGE;
            this._wrapT = Texture.CLAMP_TO_EDGE;
            this._textureWidth = 0;
            this._textureHeight = 0;
            this._unrefImageDataAfterApply = false;
            this.setInternalFormat( Texture.RGBA );
            this._textureTarget = Texture.TEXTURE_2D;
            this._type = Texture.UNSIGNED_BYTE;
        },
        getTextureTarget: function () {
            return this._textureTarget;
        },
        getTextureObject: function () {
            return this._textureObject;
        },
        setTextureSize: function ( w, h ) {
            this._textureWidth = w;
            this._textureHeight = h;
        },
        init: function ( gl ) {
            if ( !this._textureObject ) {
                this._textureObject = gl.createTexture();
                this.dirty();
            }
        },
        addApplyTexImage2DCallback: function ( callback ) {
            var index = this._applyTexImage2DCallbacks.indexOf( callback );
            if ( index &lt; 0 ) {
                this._applyTexImage2DCallbacks.push( callback );
            }
        },
        removeApplyTexImage2DCallback: function ( callback ) {
            var index = this._applyTexImage2DCallbacks.indexOf( callback );
            if ( index &gt;= 0 ) {
                this._applyTexImage2DCallbacks.splice( index, 1 );
            }
        },
        getWidth: function () {
            return this._textureWidth;
        },
        getHeight: function () {
            return this._textureHeight;
        },
        releaseGLObjects: function ( gl ) {
            if ( this._textureObject !== undefined &amp;&amp; this._textureObject !== null ) {
                gl.deleteTexture( this._textureObject );
                this._textureObject = null;
                this._image = undefined;
            }
        },
        setWrapS: function ( value ) {
            if ( typeof ( value ) === &#039;string&#039; ) {
                this._wrapS = Texture[ value ];
            } else {
                this._wrapS = value;
            }
        },
        setWrapT: function ( value ) {
            if ( typeof ( value ) === &#039;string&#039; ) {
                this._wrapT = Texture[ value ];
            } else {
                this._wrapT = value;
            }
        },

        getWrapT: function () {
            return this._wrapT;
        },
        getWrapS: function () {
            return this._wrapS;
        },
        getMinFilter: function () {
            return this._minFilter;
        },
        getMagFilter: function () {
            return this._magFilter;
        },

        setMinFilter: function ( value ) {
            if ( typeof ( value ) === &#039;string&#039; ) {
                this._minFilter = Texture[ value ];
            } else {
                this._minFilter = value;
            }
        },
        setMagFilter: function ( value ) {
            if ( typeof ( value ) === &#039;string&#039; ) {
                this._magFilter = Texture[ value ];
            } else {
                this._magFilter = value;
            }
        },

        setImage: function ( img, imageFormat ) {

            var image = img;
            if ( img instanceof window.Image ||
                 img instanceof HTMLCanvasElement ||
                 img instanceof Uint8Array ) {
                     image = new Image( img );
                 }

            this._image = image;
            this.setImageFormat( imageFormat );
            this.dirty();
        },
        getImage: function () {
            return this._image;
        },
        setImageFormat: function ( imageFormat ) {
            if ( imageFormat ) {
                if ( typeof ( imageFormat ) === &#039;string&#039; ) {
                    imageFormat = Texture[ imageFormat ];
                }
                this._imageFormat = imageFormat;
            } else {
                this._imageFormat = Texture.RGBA;
            }
            this.setInternalFormat( this._imageFormat );
        },
        setType: function ( value ) {
            if ( typeof ( value ) === &#039;string&#039; ) {
                this._type = Texture[ value ];
            } else {
                this._type = value;
            }
        },
        setUnrefImageDataAfterApply: function ( bool ) {
            this._unrefImageDataAfterApply = bool;
        },
        setInternalFormat: function ( internalFormat ) {
            this._internalFormat = internalFormat;
        },
        getInternalFormat: function () {
            return this._internalFormat;
        },

        applyFilterParameter: function ( gl, target ) {

            var powerOfTwo = isPowerOf2( this._textureWidth ) &amp;&amp; isPowerOf2( this._textureHeight );
            if ( !powerOfTwo ) {
                this.setWrapT( Texture.CLAMP_TO_EDGE );
                this.setWrapS( Texture.CLAMP_TO_EDGE );

                if ( this._minFilter === Texture.LINEAR_MIPMAP_LINEAR ||
                     this._minFilter === Texture.LINEAR_MIPMAP_NEAREST ) {
                         this.setMinFilter( Texture.LINEAR );
                     }
            }

            gl.texParameteri( target, gl.TEXTURE_MAG_FILTER, this._magFilter );
            gl.texParameteri( target, gl.TEXTURE_MIN_FILTER, this._minFilter );
            gl.texParameteri( target, gl.TEXTURE_WRAP_S, this._wrapS );
            gl.texParameteri( target, gl.TEXTURE_WRAP_T, this._wrapT );
        },

        generateMipmap: function ( gl, target ) {
            if ( this._minFilter === gl.NEAREST_MIPMAP_NEAREST ||
                 this._minFilter === gl.LINEAR_MIPMAP_NEAREST ||
                 this._minFilter === gl.NEAREST_MIPMAP_LINEAR ||
                 this._minFilter === gl.LINEAR_MIPMAP_LINEAR ) {
                     gl.generateMipmap( target );
                 }
        },
        applyTexImage2D: function ( gl ) {
            var args = Array.prototype.slice.call( arguments, 1 );
            gl.texImage2D.apply( gl, args );

            // call a callback when upload is done if there is one
            var numCallback = this._applyTexImage2DCallbacks.length;
            if ( numCallback &gt; 0 ) {
                for ( var i = 0, l = numCallback; i &lt; l; i++ ) {
                    this._applyTexImage2DCallbacks[ i ].call( this );
                }
            }
        },

        apply: function ( state ) {
            var gl = state.getGraphicContext();
            if ( this._textureObject !== undefined &amp;&amp; !this.isDirty() ) {
                gl.bindTexture( this._textureTarget, this._textureObject );
            } else if ( this.defaultType ) {
                gl.bindTexture( this._textureTarget, null );
            } else {
                var image = this._image;
                if ( image !== undefined ) {

                    // when data is ready we will upload it to the gpu
                    if ( image.isReady() ) {

                        if ( !this._textureObject ) {
                            this.init( gl );
                        }

                        this.setDirty( false );
                        gl.bindTexture( this._textureTarget, this._textureObject );

                        var imgWidth = image.getWidth() || this._textureWidth;
                        var imgHeight = image.getHeight() || this._textureHeight;

                        this.setTextureSize( imgWidth, imgHeight );
                        if ( image.isTypedArray() ) {
                            this.applyTexImage2D( gl,
                                                  this._textureTarget,
                                                  0,
                                                  this._internalFormat,
                                                  this._textureWidth,
                                                  this._textureHeight,
                                                  0,
                                                  this._internalFormat,
                                                  this._type,
                                                  this._image.getImage() );
                        } else {
                            this.applyTexImage2D( gl,
                                                  this._textureTarget,
                                                  0,
                                                  this._internalFormat,
                                                  this._imageFormat,
                                                  this._type,
                                                  image.getImage() );
                        }

                        this.applyFilterParameter( gl, this._textureTarget );
                        this.generateMipmap( gl, this._textureTarget );

                        if ( this._unrefImageDataAfterApply ) {
                            this._image = undefined;
                        }

                    } else {
                        gl.bindTexture( this._textureTarget, null );
                    }

                } else if ( this._textureHeight !== 0 &amp;&amp; this._textureWidth !== 0 ) {
                    if ( !this._textureObject ) {
                        this.init( gl );
                    }
                    gl.bindTexture( this._textureTarget, this._textureObject );
                    this.applyTexImage2D( gl, this._textureTarget, 0, this._internalFormat, this._textureWidth, this._textureHeight, 0, this._internalFormat, this._type, null );

                    this.applyFilterParameter( gl, this._textureTarget );
                    this.generateMipmap( gl, this._textureTarget );
                    this.setDirty( false );
                }
            }
        },


        /**
         set the injection code that will be used in the shader generation
         for FragmentMain part we would write something like that
         @example
         var fragmentGenerator = function(unit) {
         var str = &#039;texColor&#039; + unit + &#039; = texture2D( Texture&#039; + unit + &#039;, FragTexCoord&#039; + unit + &#039;.xy );\n&#039;;
         str += &#039;fragColor = fragColor * texColor&#039; + unit + &#039;;\n&#039;;
         };
         setShaderGeneratorFunction(fragmentGenerator, ShaderGenerator.Type.FragmentMain);

         */
        setShaderGeneratorFunction: function (
            /**Function*/
            injectionFunction,
            /**ShaderGenerator.Type*/
            mode ) {
                this[ mode ] = injectionFunction;
            },

        generateShader: function ( unit, type ) {
            if ( this[ type ] ) {
                return this[ type ].call( this, unit );
            }
            return &#039;&#039;;
        }
    } ), &#039;osg&#039;, &#039;Texture&#039; );

    Texture.prototype[ ShaderGenerator.Type.VertexInit ] = function ( unit ) {
        var str = &#039;attribute vec2 TexCoord&#039; + unit + &#039;;\n&#039;;
        str += &#039;varying vec2 FragTexCoord&#039; + unit + &#039;;\n&#039;;
        return str;
    };
    Texture.prototype[ ShaderGenerator.Type.VertexMain ] = function ( unit ) {
        return &#039;FragTexCoord&#039; + unit + &#039; = TexCoord&#039; + unit + &#039;;\n&#039;;
    };
    Texture.prototype[ ShaderGenerator.Type.FragmentInit ] = function ( unit ) {
        var str = &#039;varying vec2 FragTexCoord&#039; + unit + &#039;;\n&#039;;
        str += &#039;uniform sampler2D Texture&#039; + unit + &#039;;\n&#039;;
        str += &#039;vec4 texColor&#039; + unit + &#039;;\n&#039;;
        return str;
    };
    Texture.prototype[ ShaderGenerator.Type.FragmentMain ] = function ( unit ) {
        var str = &#039;texColor&#039; + unit + &#039; = texture2D( Texture&#039; + unit + &#039;, FragTexCoord&#039; + unit + &#039;.xy );\n&#039;;
        str += &#039;fragColor = fragColor * texColor&#039; + unit + &#039;;\n&#039;;
        return str;
    };


    Texture.createFromURL = function ( imageSource, format ) {
        var texture = new Texture();
        Q.when( ReaderParser.readImage( imageSource ) ).then(
            function ( img ) {
                texture.setImage( img, format );
            }
        );
        return texture;
    };

    Texture.createFromImage = function ( image, format ) {
        var a = new Texture();
        a.setImage( image, format );
        return a;
    };

    Texture.createFromCanvas = function ( canvas, format ) {
        return Texture.createFromImage( canvas, format );
    };

    Texture.create = function ( url ) {
        Notify.log( &#039;Texture.create is deprecated, use Texture.createFromURL instead&#039; );
        return Texture.createFromURL( url );
    };

    return Texture;
} );</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
