<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title></title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/jsoverson/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>osgUtil/Composer.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"></i></a></h2>
      <p class="stat">62.10</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h2>
      <p class="stat">1271</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty"></i></a></h2>
      <p class="stat">75.05</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs"></i></a></h2>
      <p class="stat">13.62</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">define( [
    &#039;osg/Notify&#039;,
    &#039;osg/Utils&#039;,
    &#039;osg/Node&#039;,
    &#039;osg/Depth&#039;,
    &#039;osg/Texture&#039;,
    &#039;osg/Camera&#039;,
    &#039;osg/FrameBufferObject&#039;,
    &#039;osg/Viewport&#039;,
    &#039;osg/Matrix&#039;,
    &#039;osg/Uniform&#039;,
    &#039;osg/StateSet&#039;,
    &#039;osg/Program&#039;,
    &#039;osg/Shader&#039;,
    &#039;osg/Shape&#039;,
    &#039;osg/TransformEnums&#039;,
    &#039;osg/Vec3&#039;
], function ( Notify, MACROUTILS, Node, Depth, Texture, Camera, FrameBufferObject, Viewport, Matrix,  Uniform, StateSet, Program, Shader, Shape, TransformEnums, Vec3 ) {

    /*
     Composer is an helper to create post fx. The idea is to push one or more textures into a pipe of shader filter.

     how to use it:

     // example how to blur a texture and render it to screen
     var myTexture; // imagine it&#039;s your texture you want to process
     var composer = new Composer();
     composer.addPass(new Composer.Filter.InputTexture(myTexture));
     composer.addPass(new Composer.Filter.HBlur(5));
     composer.addPass(new Composer.Filter.VBlur(5));
     composer.renderToScreen(1200, 900);
     composer.build(); // if you dont build manually it will be done in the scenegraph while upading
     rootnode.addChild(composer);

     // now you can imagine to some process and use the result as input texture for a geometry
     var myTexture; // imagine it&#039;s your texture you want to process
     var myResultTexture = new Texture(); // imagine it&#039;s your texture you want to process
     myResultTexture.setTextureSize(1200,900);
     var composer = new Composer();
     composer.addPass(new Composer.Filter.InputTexture(myTexture));
     composer.addPass(new Composer.Filter.HBlur(5));
     composer.addPass(new Composer.Filter.VBlur(5), resultTexture);

     myGeometry.getStateSet().setTextureAttributeAndModes(0, resultTexture);
     rootnode.addChild(composer);

     */

    var Composer = function () {
        Node.call( this );
        this._stack = [];
        this._renderToScreen = false;
        this._dirty = false;
        var UpdateCallback = function () {

        };
        UpdateCallback.prototype = {
            update: function ( node /*, nv */ ) {
                if ( node.isDirty() ) {
                    node.build();
                }
            }
        };
        this.setUpdateCallback( new UpdateCallback() );
        this.getOrCreateStateSet().setAttributeAndModes( new Depth( &#039;DISABLE&#039; ) );
    };

    Composer.prototype = MACROUTILS.objectInehrit( Node.prototype, {
        dirty: function () {
            for ( var i = 0, l = this._stack.length; i &lt; l; i++ ) {
                this._stack[ i ].filter.dirty();
            }
        },

        // addPass support different signature
        // addPass(filter) -&gt; the filter will be done on a texture of the same size than the previous pass
        // addPass(filter, textureWidth, textureHeight) -&gt; the filter will be done on a texture width and height
        // addPass(filter, texture) -&gt; the filter will be done on the giver texture using its width and height
        addPass: function ( filter, arg0, arg1 ) {
            if ( arg0 instanceof Texture ) {
                this._stack.push( {
                    filter: filter,
                    texture: arg0
                } );
            } else if ( arg0 !== undefined &amp;&amp; arg1 !== undefined ) {
                this._stack.push( {
                    filter: filter,
                    width: Math.floor( arg0 ),
                    height: Math.floor( arg1 )
                } );
            } else {
                this._stack.push( {
                    filter: filter
                } );
            }
        },
        renderToScreen: function ( w, h ) {
            this._renderToScreen = true;
            this._renderToScreenWidth = w;
            this._renderToScreenHeight = h;
        },

        isDirty: function () {
            for ( var i = 0, l = this._stack.length; i &lt; l; i++ ) {
                if ( this._stack[ i ].filter.isDirty() ) {
                    return true;
                }
            }
            return false;
        },

        build: function () {
            var root = this;
            this.removeChildren();
            var lastTextureResult;
            var self = this;
            this._stack.forEach( function ( element, i, array ) {
                if ( element.filter.isDirty() ) {
                    element.filter.build();
                }
                var stateSet = element.filter.getStateSet();
                var w, h;
                if ( element.texture !== undefined ) {
                    w = element.texture.getWidth();
                    h = element.texture.getHeight();
                } else if ( element.width !== undefined &amp;&amp; element.height !== undefined ) {
                    w = element.width;
                    h = element.height;
                } else {
                    // get width from Texture0
                    var inputTexture = stateSet.getTextureAttribute( 0, &#039;Texture&#039; );
                    if ( inputTexture === undefined ) {
                        Notify.warn( &#039;Composer can\&#039;t find any information to setup texture output size&#039; );
                    }
                    w = inputTexture.getWidth();
                    h = inputTexture.getHeight();
                }

                // is it the last filter and we want to render to screen ?
                var lastFilterRenderToScreen = ( i === array.length - 1 &amp;&amp;
                    self._renderToScreen === true );

                // check if we have something to do
                // else we will just translate stateset to the next filter
                // this part exist to manage the Composer.Filter.InputTexture that setup the first texture unit
                if ( !lastFilterRenderToScreen ) {
                    if ( stateSet.getAttribute( &#039;Program&#039; ) === undefined ) {
                        array[ i + 1 ].filter.getStateSet().setTextureAttributeAndModes( 0, stateSet.getTextureAttribute( 0, &#039;Texture&#039; ) );
                        return;
                    }
                }

                // check if we want to render on screen
                var camera = new Camera();
                camera.setClearMask( 0 );

                var texture;
                var quad;
                if ( lastFilterRenderToScreen === true ) {
                    w = self._renderToScreenWidth;
                    h = self._renderToScreenHeight;
                } else {
                    camera.setRenderOrder( Camera.PRE_RENDER, 0 );
                    texture = element.texture;
                    if ( texture === undefined ) {
                        texture = new Texture();
                        texture.setTextureSize( w, h );
                    }
                    camera.attachTexture( FrameBufferObject.COLOR_ATTACHMENT0, texture, 0 );
                }

                var vp = new Viewport( 0, 0, w, h );
                var projection = Matrix.makeOrtho( -w / 2, w / 2, -h / 2, h / 2, -5, 5, [] );
                camera.setReferenceFrame( TransformEnums.ABSOLUTE_RF );
                camera.setViewport( vp );
                camera.setProjectionMatrix( projection );
                camera.setStateSet( element.filter.getStateSet() );

                quad = Shape.createTexturedQuadGeometry( -w / 2, -h / 2, 0,
                    w, 0, 0,
                    0, h, 0 );

                if ( element.filter.buildGeometry !== undefined )
                    quad = element.filter.buildGeometry( quad );

                quad.setName( &#039;composer layer&#039; );

                lastTextureResult = texture;

                // assign the result texture to the next stateset
                if ( i + 1 &lt; array.length ) {
                    array[ i + 1 ].filter.getStateSet().setTextureAttributeAndModes( 0, lastTextureResult );
                }

                camera.addChild( quad );
                element.filter.getStateSet().addUniform( Uniform.createFloat2( [ w, h ], &#039;RenderSize&#039; ) );
                camera.setName( &#039;Composer Pass&#039; + i );
                root.addChild( camera );
            } );
            this._resultTexture = lastTextureResult;
        }
    } );

    Composer.Filter = function () {
        this._stateSet = new StateSet();
        this._dirty = true;
    };

    Composer.Filter.prototype = {
        getStateSet: function () {
            return this._stateSet;
        },
        getOrCreateStateSet: function () {
            return this._stateSet;
        },
        dirty: function () {
            this._dirty = true;
        },
        isDirty: function () {
            return this._dirty;
        }
    };


    Composer.Filter.defaultVertexShader = [
        &#039;#ifdef GL_ES&#039;,
        &#039;precision highp float;&#039;,
        &#039;#endif&#039;,
        &#039;attribute vec3 Vertex;&#039;,
        &#039;attribute vec2 TexCoord0;&#039;,
        &#039;varying vec2 FragTexCoord0;&#039;,
        &#039;uniform mat4 ModelViewMatrix;&#039;,
        &#039;uniform mat4 ProjectionMatrix;&#039;,
        &#039;void main(void) {&#039;,
        &#039;  gl_Position = ProjectionMatrix * ModelViewMatrix * vec4(Vertex,1.0);&#039;,
        &#039;  FragTexCoord0 = TexCoord0;&#039;,
        &#039;}&#039;,
        &#039;&#039;
    ].join( &#039;\n&#039; );

    Composer.Filter.defaultFragmentShaderHeader = [
        &#039;#ifdef GL_ES&#039;,
        &#039;precision highp float;&#039;,
        &#039;#endif&#039;,
        &#039;varying vec2 FragTexCoord0;&#039;,
        &#039;uniform vec2 RenderSize;&#039;,
        &#039;uniform sampler2D Texture0;&#039;,
        &#039;&#039;
    ].join( &#039;\n&#039; );

    Composer.Filter.shaderUtils = [
        &#039;vec4 packFloatTo4x8(in float v) {&#039;,
        &#039;vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;&#039;,
        &#039;enc = fract(enc);&#039;,
        &#039;enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);&#039;,
        &#039;return enc;&#039;,
        &#039;}&#039;,

        &#039; &#039;,
        &#039;vec4 pack2FloatTo4x8(in vec2 val) {&#039;,
        &#039; const vec2 bitSh = vec2(256.0, 1.0);&#039;,
        &#039; const vec2 bitMsk = vec2(0.0, 1.0/256.0);&#039;,
        &#039; vec2 res1 = fract(val.x * bitSh);&#039;,
        &#039; res1 -= res1.xx * bitMsk;&#039;,
        &#039; vec2 res2 = fract(val.y * bitSh);&#039;,
        &#039; res2 -= res2.xx * bitMsk;&#039;,
        &#039; return vec4(res1.x,res1.y,res2.x,res2.y);&#039;,
        &#039;}&#039;,
        &#039; &#039;,
        &#039;float unpack4x8ToFloat( vec4 rgba ) {&#039;,
        &#039; return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );&#039;,
        &#039;}&#039;,
        &#039; &#039;,
        &#039;vec2 unpack4x8To2Float(in vec4 val) {&#039;,
        &#039; const vec2 unshift = vec2(1.0/256.0, 1.0);&#039;,
        &#039; return vec2(dot(val.xy, unshift), dot(val.zw, unshift));&#039;,
        &#039;}&#039;,

        &#039;vec2 encodeNormal (vec3 n)&#039;,
        &#039;{&#039;,
        &#039;    float f = sqrt(8.0*n.z+8.0);&#039;,
        &#039;    return n.xy / f + 0.5;&#039;,
        &#039;}&#039;,

        &#039;vec3 decodeNormal (vec2 enc)&#039;,
        &#039;{&#039;,
        &#039;    vec2 fenc = enc*4.0-2.0;&#039;,
        &#039;    float f = dot(fenc,fenc);&#039;,
        &#039;    float g = sqrt(1.0-f/4.0);&#039;,
        &#039;    vec3 n;&#039;,
        &#039;    n.xy = fenc*g;&#039;,
        &#039;    n.z = 1.0-f/2.0;&#039;,
        &#039;    return n;&#039;,
        &#039;}&#039;,
        &#039;&#039;
    ].join( &#039;\n&#039; );

    Composer.Filter.Helper = {
        getOrCreatePascalCoefficients: function () {
            var cache = Composer.Filter.Helper.getOrCreatePascalCoefficients.cache;
            if ( cache !== undefined ) {
                return cache;
            }

            cache = ( function ( kernelSize ) {
                var pascalTriangle = [
                    [ 1 ]
                ];
                for ( var j = 0; j &lt; ( kernelSize - 1 ); j++ ) {
                    //var sum = Math.pow( 2, j );
                    var currentRow = pascalTriangle[ j ];
                    var currentRowSize = currentRow.length;

                    var nextRowSize = currentRowSize + 1;
                    var nextRow = new Array( currentRowSize );
                    nextRow[ 0 ] = 1.0;
                    nextRow[ nextRowSize - 1 ] = 1.0;

                    var idx = 1;
                    for ( var p = 0; p &lt; currentRowSize - 1; p++ ) {
                        var val = ( currentRow[ p ] + currentRow[ p + 1 ] );
                        nextRow[ idx++ ] = val;
                    }
                    pascalTriangle.push( nextRow );
                }

                // compute real coef dividing by sum
                ( function () {
                    for ( var a = 0; a &lt; pascalTriangle.length; a++ ) {
                        var row = pascalTriangle[ a ];
                        //var str = &#039;&#039;;

                        var sum = Math.pow( 2, a );
                        for ( var i = 0; i &lt; row.length; i++ ) {
                            row[ i ] = row[ i ] / sum;
                            //str += row[i].toString() + &#039; &#039;;
                        }
                        //console.log(str);
                    }
                } )();

                return pascalTriangle;
            } )( 20 );
            Composer.Filter.Helper.getOrCreatePascalCoefficients.cache = cache;
            return cache;
        }
    };

    Composer.Filter.Custom = function ( fragmentShader, uniforms ) {
        Composer.Filter.call( this );
        this._fragmentShader = fragmentShader;
        this._uniforms = uniforms;
        this._vertexShader = Composer.Filter.defaultVertexShader;
    };

    Composer.Filter.Custom.prototype = MACROUTILS.objectInehrit( Composer.Filter.prototype, {
        build: function () {

            var program = new Program(
                new Shader( &#039;VERTEX_SHADER&#039;, this._vertexShader ),
                new Shader( &#039;FRAGMENT_SHADER&#039;, this._fragmentShader ) );

            if ( this._uniforms ) {
                var unitIndex = 0;

                var r = this._fragmentShader.match( /uniform\s+\w+\s+\w+/g );
                if ( r !== null ) {
                    for ( var i = 0, l = r.length; i &lt; l; i++ ) {
                        var match = r[ i ].match( /uniform\s+(\w+)\s+(\w+)/ );
                        var uniformType = match[ 1 ];
                        var uniformName = match[ 2 ];
                        var uniform;

                        if ( this._uniforms[ uniformName ] !== undefined ) {
                            var uniformValue = this._uniforms[ uniformName ];
                            if ( uniformType.search( &#039;sampler&#039; ) !== -1 ) {
                                this._stateSet.setTextureAttributeAndModes( unitIndex, uniformValue );
                                uniform = Uniform.createInt1( unitIndex, uniformName );
                                unitIndex++;
                                this._stateSet.addUniform( uniform );
                            } else {
                                if ( Uniform.isUniform( uniformValue ) ) {
                                    uniform = uniformValue;
                                } else {
                                    uniform = Uniform[ uniformType ]( this._uniforms[ uniformName ], uniformName );
                                }
                                this._stateSet.addUniform( uniform );
                            }
                        }
                    }
                }
            }
            this._stateSet.setAttributeAndModes( program );
            this._dirty = false;
        }
    } );



    Composer.Filter.AverageHBlur = function ( nbSamplesOpt ) {
        Composer.Filter.call( this );
        if ( nbSamplesOpt === undefined ) {
            this.setBlurSize( 5 );
        } else {
            this.setBlurSize( nbSamplesOpt );
        }
        this._pixelSize = 1.0;
    };

    Composer.Filter.AverageHBlur.prototype = MACROUTILS.objectInehrit( Composer.Filter.prototype, {
        setBlurSize: function ( nbSamples ) {
            if ( nbSamples % 2 !== 1 ) {
                nbSamples += 1;
            }
            this._nbSamples = nbSamples;
            this.dirty();
        },
        setPixelSize: function ( value ) {
            this._pixelSize = value;
            this.dirty();
        },
        getUVOffset: function ( value ) {
            return &#039;vec2(float(&#039; + value + &#039;), 0.0)/RenderSize[0];&#039;;
        },
        getShaderBlurKernel: function () {
            var nbSamples = this._nbSamples;
            var kernel = [];
            kernel.push( &#039; pixel = texture2D(Texture0, FragTexCoord0 );&#039; );
            kernel.push( &#039; if (pixel.w == 0.0) { gl_FragColor = pixel; return; }&#039; );
            kernel.push( &#039; vec2 offset;&#039; );
            for ( var i = 1; i &lt; Math.ceil( nbSamples / 2 ); i++ ) {
                kernel.push( &#039; offset = &#039; + this.getUVOffset( i * this._pixelSize ) );
                kernel.push( &#039; pixel += texture2D(Texture0, FragTexCoord0 + offset);&#039; );
                kernel.push( &#039; pixel += texture2D(Texture0, FragTexCoord0 - offset);&#039; );
            }
            kernel.push( &#039; pixel /= float(&#039; + nbSamples + &#039;);&#039; );
            return kernel;
        },
        build: function () {
            //var nbSamples = this._nbSamples;
            var vtx = Composer.Filter.defaultVertexShader;
            var fgt = [
                Composer.Filter.defaultFragmentShaderHeader,
                &#039;uniform float width;&#039;,

                &#039;void main (void)&#039;,
                &#039;{&#039;,
                &#039;  vec4 pixel;&#039;,
                this.getShaderBlurKernel().join( &#039;\n&#039; ),
                &#039;  gl_FragColor = vec4(pixel);&#039;,
                &#039;}&#039;,
                &#039;&#039;
            ].join( &#039;\n&#039; );

            var program = new Program(
                new Shader( &#039;VERTEX_SHADER&#039;, vtx ),
                new Shader( &#039;FRAGMENT_SHADER&#039;, fgt ) );

            if ( this._stateSet.getUniform( &#039;Texture0&#039; ) === undefined ) {
                this._stateSet.addUniform( Uniform.createInt1( 0, &#039;Texture0&#039; ) );
            }
            this._stateSet.setAttributeAndModes( program );
            this._dirty = false;
        }
    } );


    Composer.Filter.AverageVBlur = function ( nbSamplesOpt ) {
        Composer.Filter.AverageHBlur.call( this, nbSamplesOpt );
    };
    Composer.Filter.AverageVBlur.prototype = MACROUTILS.objectInehrit( Composer.Filter.AverageHBlur.prototype, {
        getUVOffset: function ( value ) {
            return &#039;vec2(0.0, float(&#039; + value + &#039;))/RenderSize[1];&#039;;
        }
    } );

    Composer.Filter.BilateralHBlur = function ( options ) {
        Composer.Filter.call( this );

        if ( options === undefined ) {
            options = {};
        }

        var nbSamplesOpt = options.nbSamples;
        var depthTexture = options.depthTexture;
        var radius = options.radius;

        if ( nbSamplesOpt === undefined ) {
            this.setBlurSize( 5 );
        } else {
            this.setBlurSize( nbSamplesOpt );
        }
        this._depthTexture = depthTexture;
        this._radius = Uniform.createFloat( 1.0, &#039;radius&#039; );
        this._pixelSize = Uniform.createFloat( 1.0, &#039;pixelSize&#039; );
        this.setRadius( radius );
    };

    Composer.Filter.BilateralHBlur.prototype = MACROUTILS.objectInehrit( Composer.Filter.prototype, {
        setBlurSize: function ( nbSamples ) {
            if ( nbSamples % 2 !== 1 ) {
                nbSamples += 1;
            }
            //Notify.log(&#039;BlurSize &#039; + nbSamples);
            this._nbSamples = nbSamples;
            this.dirty();
        },
        setPixelSize: function ( value ) {
            this._pixelSize.get()[ 0 ] = value;
            this._pixelSize.dirty();
        },
        setRadius: function ( radius ) {
            this._radius.get()[ 0 ] = radius; // *2.0;
            this._radius.dirty();
        },
        getUVOffset: function ( value ) {
            return &#039;vec2(0.0, float(&#039; + value + &#039;) * pixelSize )/RenderSize[1];&#039;;
        },
        getShaderBlurKernel: function () {
            var nbSamples = this._nbSamples;
            var kernel = [];
            kernel.push( &#039; pixel = texture2D(Texture0, FragTexCoord0 );&#039; );
            kernel.push( &#039; if (pixel.w &lt;= 0.0001) { gl_FragColor = vec4(1.0); return; }&#039; );
            kernel.push( &#039; vec2 offset, tmpUV;&#039; );
            kernel.push( &#039; depth = getDepthValue(texture2D(Texture1, FragTexCoord0 ));&#039; );
            for ( var i = 1; i &lt; Math.ceil( nbSamples / 2 ); i++ ) {
                kernel.push( &#039; offset = &#039; + this.getUVOffset( i ) );

                kernel.push( &#039; tmpUV =  FragTexCoord0 + offset;&#039; );
                kernel.push( &#039; tmpDepth = getDepthValue(texture2D(Texture1, tmpUV ));&#039; );
                kernel.push( &#039; if ( abs(depth-tmpDepth) &lt; radius) {&#039; );
                kernel.push( &#039;   pixel += texture2D(Texture0, tmpUV);&#039; );
                kernel.push( &#039;   nbHits += 1.0;&#039; );
                kernel.push( &#039; }&#039; );

                kernel.push( &#039; tmpUV =  FragTexCoord0 - offset;&#039; );
                kernel.push( &#039; tmpDepth = getDepthValue(texture2D(Texture1, tmpUV ));&#039; );
                kernel.push( &#039; if ( abs(depth-tmpDepth) &lt; radius) {&#039; );
                kernel.push( &#039;   pixel += texture2D(Texture0, tmpUV);&#039; );
                kernel.push( &#039;   nbHits += 1.0;&#039; );
                kernel.push( &#039; }&#039; );
            }
            kernel.push( &#039; pixel /= nbHits;&#039; );
            return kernel;
        },
        build: function () {
            //var nbSamples = this._nbSamples;
            var vtx = Composer.Filter.defaultVertexShader;
            var fgt = [
                Composer.Filter.defaultFragmentShaderHeader,
                &#039;uniform sampler2D Texture1;&#039;,
                &#039;uniform float width;&#039;,
                &#039;uniform mat4 projection;&#039;,
                &#039;uniform float radius;&#039;,
                &#039;uniform float pixelSize;&#039;,

                &#039;float znear,zfar,zrange;&#039;,
                &#039;&#039;,
                Composer.Filter.shaderUtils,
                &#039;&#039;,
                &#039;float getDepthValue(vec4 v) {&#039;,
                &#039;  float depth = unpack4x8ToFloat(v);&#039;,
                &#039;  depth = depth*zrange+znear;&#039;,
                &#039;  return -depth;&#039;,
                &#039;}&#039;,

                &#039;void main (void)&#039;,
                &#039;{&#039;,
                &#039;  vec4 pixel;&#039;,
                &#039;  float depth, tmpDepth;&#039;,
                &#039;  znear = projection[3][2] / (projection[2][2]-1.0);&#039;,
                &#039;  zfar = projection[3][2] / (projection[2][2]+1.0);&#039;,
                &#039;  zrange = zfar-znear;&#039;,
                &#039;  float nbHits = 1.0;&#039;,

                this.getShaderBlurKernel().join( &#039;\n&#039; ),
                &#039;  gl_FragColor = vec4(pixel);&#039;,
                &#039;}&#039;,
                &#039;&#039;
            ].join( &#039;\n&#039; );

            var program = new Program(
                new Shader( &#039;VERTEX_SHADER&#039;, vtx ),
                new Shader( &#039;FRAGMENT_SHADER&#039;, fgt ) );

            if ( this._stateSet.getUniform( &#039;Texture0&#039; ) === undefined ) {
                this._stateSet.addUniform( Uniform.createInt1( 0, &#039;Texture0&#039; ) );
            }
            if ( this._stateSet.getUniform( &#039;Texture1&#039; ) === undefined ) {
                this._stateSet.addUniform( Uniform.createInt1( 1, &#039;Texture1&#039; ) );
            }
            this._stateSet.addUniform( this._radius );
            this._stateSet.addUniform( this._pixelSize );
            this._stateSet.setTextureAttributeAndModes( 1, this._depthTexture );
            this._stateSet.setAttributeAndModes( program );
            this._dirty = false;
        }
    } );

    Composer.Filter.BilateralVBlur = function ( options ) {
        Composer.Filter.BilateralHBlur.call( this, options );
    };

    Composer.Filter.BilateralVBlur.prototype = MACROUTILS.objectInehrit( Composer.Filter.BilateralHBlur.prototype, {
        getUVOffset: function ( value ) {
            return &#039;vec2(float(&#039; + value + &#039;)*pixelSize,0.0)/RenderSize[0];&#039;;
        }
    } );

    // InputTexture is a fake filter to setup the first texture
    // in the composer pipeline
    Composer.Filter.InputTexture = function ( texture ) {
        Composer.Filter.call( this );
        this._stateSet.setTextureAttributeAndModes( 0, texture );
    };
    Composer.Filter.InputTexture.prototype = MACROUTILS.objectInehrit( Composer.Filter.prototype, {
        build: function () {
            this._dirty = false;
        }
    } );

    // Operate a Gaussian horizontal blur
    Composer.Filter.HBlur = function ( nbSamplesOpt ) {
        Composer.Filter.call( this );
        if ( nbSamplesOpt === undefined ) {
            this.setBlurSize( 5 );
        } else {
            this.setBlurSize( nbSamplesOpt );
        }
    };

    Composer.Filter.HBlur.prototype = MACROUTILS.objectInehrit( Composer.Filter.prototype, {
        setBlurSize: function ( nbSamples ) {
            if ( nbSamples % 2 !== 1 ) {
                nbSamples += 1;
            }
            this._nbSamples = nbSamples;
            this.dirty();
        },
        getUVOffset: function ( value ) {
            return &#039;vec2(float(&#039; + value + &#039;), 0.0)/RenderSize[0];&#039;;
        },
        build: function () {
            var nbSamples = this._nbSamples;
            var vtx = Composer.Filter.defaultVertexShader;
            var pascal = Composer.Filter.Helper.getOrCreatePascalCoefficients();
            var weights = pascal[ nbSamples - 1 ];
            var start = Math.floor( nbSamples / 2.0 );
            var kernel = [];
            kernel.push( &#039; pixel += float(&#039; + weights[ start ] + &#039;)*texture2D(Texture0, FragTexCoord0 ).rgb;&#039; );
            var offset = 1;
            kernel.push( &#039; vec2 offset;&#039; );
            for ( var i = start + 1; i &lt; nbSamples; i++ ) {
                var weight = weights[ i ];
                kernel.push( &#039; offset = &#039; + this.getUVOffset( i ) );
                offset++;
                kernel.push( &#039; pixel += &#039; + weight + &#039;*texture2D(Texture0, FragTexCoord0 + offset).rgb;&#039; );
                kernel.push( &#039; pixel += &#039; + weight + &#039;*texture2D(Texture0, FragTexCoord0 - offset).rgb;&#039; );
            }

            var fgt = [
                Composer.Filter.defaultFragmentShaderHeader,
                &#039;uniform float width;&#039;,

                &#039;void main (void)&#039;,
                &#039;{&#039;,
                &#039;  vec3 pixel;&#039;,
                kernel.join( &#039;\n&#039; ),
                &#039;  gl_FragColor = vec4(pixel,1.0);&#039;,
                &#039;}&#039;,
                &#039;&#039;
            ].join( &#039;\n&#039; );

            var program = new Program(
                new Shader( &#039;VERTEX_SHADER&#039;, vtx ),
                new Shader( &#039;FRAGMENT_SHADER&#039;, fgt ) );

            if ( this._stateSet.getUniform( &#039;Texture0&#039; ) === undefined ) {
                this._stateSet.addUniform( Uniform.createInt1( 0, &#039;Texture0&#039; ) );
            }
            this._stateSet.setAttributeAndModes( program );
            this._dirty = false;
        }
    } );

    // Operate a Gaussian vertical blur
    Composer.Filter.VBlur = function ( /*nbSamplesOpt*/ ) {
        Composer.Filter.HBlur.call( this );
    };

    Composer.Filter.VBlur.prototype = MACROUTILS.objectInehrit( Composer.Filter.HBlur.prototype, {
        getUVOffset: function ( value ) {
            return &#039;vec2(0.0, float(&#039; + value + &#039;))/RenderSize[1];&#039;;
        }
    } );

    // Sobel filter
    // http://en.wikipedia.org/wiki/Sobel_operator
    Composer.Filter.SobelFilter = function () {
        Composer.Filter.call( this );
        this._color = Uniform.createFloat3( [ 1.0, 1.0, 1.0 ], &#039;color&#039; );
        this._factor = Uniform.createFloat( 1.0, &#039;factor&#039; );
    };

    Composer.Filter.SobelFilter.prototype = MACROUTILS.objectInehrit( Composer.Filter.prototype, {
        setColor: function ( color ) {
            this._color.get()[ 0 ] = color[ 0 ];
            this._color.get()[ 1 ] = color[ 1 ];
            this._color.get()[ 2 ] = color[ 2 ];
            this._color.dirty();
        },
        setFactor: function ( f ) {
            this._factor.get()[ 0 ] = f;
            this._factor.dirty();
        },
        build: function () {
            var stateSet = this._stateSet;
            var vtx = Composer.Filter.defaultVertexShader;
            var fgt = [
                &#039;&#039;,
                Composer.Filter.defaultFragmentShaderHeader,
                &#039;uniform vec3 color;&#039;,
                &#039;uniform float factor;&#039;,
                &#039;void main (void)&#039;,
                &#039;{&#039;,
                &#039;  float fac0 = 2.0;&#039;,
                &#039;  float fac1 = 1.0;&#039;,
                &#039;  float offsetx = 1.0/RenderSize[0];&#039;,
                &#039;  float offsety = 1.0/RenderSize[1];&#039;,
                &#039;  vec4 texel0 = texture2D(Texture0, FragTexCoord0 + vec2(offsetx, offsety));&#039;,
                &#039;  vec4 texel1 = texture2D(Texture0, FragTexCoord0 + vec2(offsetx, 0.0));&#039;,
                &#039;  vec4 texel2 = texture2D(Texture0, FragTexCoord0 + vec2(offsetx, -offsety));&#039;,
                &#039;  vec4 texel3 = texture2D(Texture0, FragTexCoord0 + vec2(0.0, -offsety));&#039;,
                &#039;  vec4 texel4 = texture2D(Texture0, FragTexCoord0 + vec2(-offsetx, -offsety));&#039;,
                &#039;  vec4 texel5 = texture2D(Texture0, FragTexCoord0 + vec2(-offsetx, 0.0));&#039;,
                &#039;  vec4 texel6 = texture2D(Texture0, FragTexCoord0 + vec2(-offsetx, offsety));&#039;,
                &#039;  vec4 texel7 = texture2D(Texture0, FragTexCoord0 + vec2(0.0, offsety));&#039;,
                &#039;  vec4 rowx = -fac0*texel5 + fac0*texel1 +  -fac1*texel6 + fac1*texel0 + -fac1*texel4 + fac1*texel2;&#039;,
                &#039;  vec4 rowy = -fac0*texel3 + fac0*texel7 +  -fac1*texel4 + fac1*texel6 + -fac1*texel2 + fac1*texel0;&#039;,
                &#039;  float mag = sqrt(dot(rowy,rowy)+dot(rowx,rowx));&#039;,
                &#039;  if (mag &lt; 1.0/255.0) { discard; return; }&#039;,
                &#039;  mag *= factor;&#039;,
                &#039;  mag = min(1.0, mag);&#039;,
                &#039;  gl_FragColor = vec4(color*mag,mag);&#039;,
                &#039;}&#039;,
                &#039;&#039;
            ].join( &#039;\n&#039; );

            var program = new Program(
                new Shader( &#039;VERTEX_SHADER&#039;, vtx ),
                new Shader( &#039;FRAGMENT_SHADER&#039;, fgt ) );

            stateSet.setAttributeAndModes( program );
            stateSet.addUniform( this._color );
            stateSet.addUniform( this._factor );
            stateSet.addUniform( Uniform.createInt1( 0, &#039;Texture0&#039; ) );
            this._dirty = false;
        }
    } );



    Composer.Filter.BlendMix = function () {
        Composer.Filter.call( this );
        var texture0, texture1, mixValue;
        var unit0 = 0;
        var unit1 = 1;
        var stateSet = this._stateSet;
        if ( arguments.length === 3 ) {
            texture0 = arguments[ 0 ];
            texture1 = arguments[ 1 ];
            mixValue = arguments[ 2 ];
            unit0 = 1;
            unit1 = 2;
            stateSet.setTextureAttributeAndModes( unit0, texture0 );
        } else if ( arguments.length === 2 ) {
            texture1 = arguments[ 0 ];
            mixValue = arguments[ 1 ];
        } else if ( arguments.length === 1 ) {
            texture1 = arguments[ 0 ];
            mixValue = 0.5;
        }
        stateSet.setTextureAttributeAndModes( unit1, texture1 );
        stateSet.addUniform( Uniform.createInt1( unit0, &#039;Texture0&#039; ) );
        stateSet.addUniform( Uniform.createInt1( unit1, &#039;Texture1&#039; ) );
        this._mixValueUniform = Uniform.createFloat1( mixValue, &#039;MixValue&#039; );
        stateSet.addUniform( this._mixValueUniform );
    };

    Composer.Filter.BlendMix = MACROUTILS.objectInehrit( Composer.Filter.prototype, {
        getBlendFactorUniform: function () {
            return this._mixValueUniform;
        },

        build: function () {
            var stateSet = this._stateSet;
            var vtx = Composer.Filter.defaultVertexShader;
            var fgt = [
                &#039;&#039;,
                Composer.Filter.defaultFragmentShaderHeader,
                &#039;uniform sampler2D Texture1;&#039;,
                &#039;uniform float MixValue;&#039;,

                &#039;void main (void)&#039;,
                &#039;{&#039;,
                &#039;  gl_FragColor = mix(texture2D(Texture0,FragTexCoord0), texture2D(Texture1,FragTexCoord0),MixValue);&#039;,
                &#039;}&#039;,
                &#039;&#039;
            ].join( &#039;\n&#039; );

            var program = new Program(
                new Shader( &#039;VERTEX_SHADER&#039;, vtx ),
                new Shader( &#039;FRAGMENT_SHADER&#039;, fgt ) );

            stateSet.setAttributeAndModes( program );
            this._dirty = false;
        }
    } );


    Composer.Filter.BlendMultiply = function () {
        Composer.Filter.call( this );
        var stateSet = this._stateSet;
        var texture0, texture1;
        var unit0 = 0;
        var unit1 = 1;
        if ( arguments.length === 2 ) {
            texture0 = arguments[ 0 ];
            texture1 = arguments[ 1 ];
            unit0 = 1;
            unit0 = 2;
            stateSet.setTextureAttributeAndModes( unit0, texture0 );
        } else if ( arguments.length === 1 ) {
            texture1 = arguments[ 0 ];
        }
        stateSet.setTextureAttributeAndModes( unit1, texture1 );
        stateSet.addUniform( Uniform.createInt1( unit0, &#039;Texture0&#039; ) );
        stateSet.addUniform( Uniform.createInt1( unit1, &#039;Texture1&#039; ) );
    };

    Composer.Filter.BlendMultiply.prototype = MACROUTILS.objectInehrit( Composer.Filter.prototype, {
        build: function () {
            var vtx = Composer.Filter.defaultVertexShader;
            var fgt = [
                &#039;&#039;,
                Composer.Filter.defaultFragmentShaderHeader,
                &#039;uniform sampler2D Texture1;&#039;,
                &#039;uniform float MixValue;&#039;,

                &#039;void main (void)&#039;,
                &#039;{&#039;,
                &#039;  gl_FragColor = texture2D(Texture0,FragTexCoord0)*texture2D(Texture1,FragTexCoord0);&#039;,
                &#039;}&#039;,
                &#039;&#039;
            ].join( &#039;\n&#039; );

            var program = new Program(
                new Shader( &#039;VERTEX_SHADER&#039;, vtx ),
                new Shader( &#039;FRAGMENT_SHADER&#039;, fgt ) );

            this._stateSet.setAttributeAndModes( program );
            this._dirty = false;
        }
    } );

    Composer.Filter.SSAO = function ( options ) {
        Composer.Filter.call( this );

        var stateSet = this._stateSet;
        var nbSamples = 16;
        var radius = 0.05;
        if ( options !== undefined ) {
            if ( options.nbSamples !== undefined )
                nbSamples = options.nbSamples;

            if ( options.radius !== undefined )
                radius = options.radius;
        }

        var textureNormal = options.normal;
        var texturePosition = options.position;
        this._radius = radius;
        this._nbSamples = nbSamples;
        this._noiseTextureSize = 16;
        this._sceneRadius = 2.0;

        stateSet.addUniform( Uniform.createFloat1( 1.0, &#039;Power&#039; ) );
        stateSet.addUniform( Uniform.createFloat1( radius, &#039;Radius&#039; ) );
        stateSet.addUniform( Uniform.createInt1( 0, &#039;Texture0&#039; ) );
        stateSet.addUniform( Uniform.createInt1( 1, &#039;Texture1&#039; ) );
        stateSet.addUniform( Uniform.createInt1( 2, &#039;Texture2&#039; ) );
        stateSet.addUniform( Uniform.createFloat1( 0.1, &#039;AngleLimit&#039; ) );

        var w = textureNormal.getWidth();
        var h = textureNormal.getHeight();
        this._size = [ w, h ];

        stateSet.setTextureAttributeAndModes( 0, textureNormal );
        stateSet.setTextureAttributeAndModes( 1, texturePosition );

        this.initNoise();

    };

    Composer.Filter.SSAO.prototype = MACROUTILS.objectInehrit( Composer.Filter.prototype, {

        initNoise: function () {
            var sizeNoise = this._noiseTextureSize;
            var noise = new Array( sizeNoise * sizeNoise * 3 );
            ( function ( array ) {
                for ( var i = 0; i &lt; sizeNoise * sizeNoise; i++ ) {
                    var x, y, z;
                    x = 2.0 * ( Math.random() - 0.5 );
                    y = 2.0 * ( Math.random() - 0.5 );
                    z = 0.0;

                    var n = Vec3.normalize( [ x, y, z ], [] );
                    array[ i * 3 + 0 ] = 255 * ( n[ 0 ] * 0.5 + 0.5 );
                    array[ i * 3 + 1 ] = 255 * ( n[ 1 ] * 0.5 + 0.5 );
                    array[ i * 3 + 2 ] = 255 * ( n[ 2 ] * 0.5 + 0.5 );
                }
            } )( noise );

            var noiseTexture = new Texture();
            noiseTexture.setWrapS( &#039;REPEAT&#039; );
            noiseTexture.setWrapT( &#039;REPEAT&#039; );
            noiseTexture.setMinFilter( &#039;NEAREST&#039; );
            noiseTexture.setMagFilter( &#039;NEAREST&#039; );

            noiseTexture.setTextureSize( sizeNoise, sizeNoise );
            noiseTexture.setImage( new Uint8Array( noise ), &#039;RGB&#039; );
            this._noiseTexture = noiseTexture;
        },
        setSceneRadius: function ( value ) {
            this._sceneRadius = value;
            this.dirty();
        },
        setAngleLimit: function ( value ) {
            var uniform = this._stateSet.getUniform( &#039;AngleLimit&#039; );
            uniform.get()[ 0 ] = value;
            uniform.dirty();
        },
        setNbSamples: function ( value ) {
            if ( value === this._nbSamples ) {
                return;
            }
            this._nbSamples = Math.floor( value );
            this.dirty();
        },
        setRadius: function ( value ) {
            var uniform = this._stateSet.getUniform( &#039;Radius&#039; );
            uniform.get()[ 0 ] = value;
            uniform.dirty();
        },
        setPower: function ( value ) {
            var uniform = this._stateSet.getUniform( &#039;Power&#039; );
            uniform.get()[ 0 ] = value;
            uniform.dirty();
        },
        build: function () {
            var stateSet = this._stateSet;
            var nbSamples = this._nbSamples;
            var kernel = new Array( nbSamples * 4 );
            ( function ( array ) {
                for ( var i = 0; i &lt; nbSamples; i++ ) {
                    var x, y, z;
                    x = 2.0 * ( Math.random() - 0.5 );
                    y = 2.0 * ( Math.random() - 0.5 );
                    z = Math.random();

                    var v = Vec3.normalize( [ x, y, z ], [] );
                    var scale = Math.max( i / nbSamples, 0.1 );
                    scale = 0.1 + ( 1.0 - 0.1 ) * ( scale * scale );
                    array[ i * 3 + 0 ] = v[ 0 ];
                    array[ i * 3 + 1 ] = v[ 1 ];
                    array[ i * 3 + 2 ] = v[ 2 ];
                    array[ i * 3 + 3 ] = scale;
                }
            } )( kernel );


            stateSet.setTextureAttributeAndModes( 2, this._noiseTexture );
            var uniform = stateSet.getUniform( &#039;noiseSampling&#039; );
            if ( uniform === undefined ) {
                uniform = Uniform.createFloat2( [ this._size[ 0 ] / this._noiseTextureSize, this._size[ 1 ] / this._noiseTextureSize ], &#039;noiseSampling&#039; );
                stateSet.addUniform( uniform );
            } else {
                uniform.set( [ this._size[ 0 ] / this._noiseTextureSize, this._size[ 1 ] / this._noiseTextureSize ] );
                uniform.dirty();
            }
            var vertexshader = [
                &#039;&#039;,
                &#039;#ifdef GL_ES&#039;,
                &#039;precision highp float;&#039;,
                &#039;#endif&#039;,
                &#039;attribute vec3 Vertex;&#039;,
                &#039;attribute vec2 TexCoord0;&#039;,
                &#039;varying vec2 FragTexCoord0;&#039;,
                &#039;uniform mat4 ModelViewMatrix;&#039;,
                &#039;uniform mat4 ProjectionMatrix;&#039;,
                &#039;void main(void) {&#039;,
                &#039;  gl_Position = ProjectionMatrix * ModelViewMatrix * vec4(Vertex,1.0);&#039;,
                &#039;  FragTexCoord0 = TexCoord0;&#039;,
                &#039;}&#039;,
                &#039;&#039;
            ].join( &#039;\n&#039; );

            var kernelglsl = [];
            for ( var i = 0; i &lt; nbSamples; i++ ) {
                kernelglsl.push( &#039;kernel[&#039; + i + &#039;] = vec4(&#039; + kernel[ i * 3 ] + &#039;,&#039; + kernel[ i * 3 + 1 ] + &#039;, &#039; + kernel[ i * 3 + 2 ] + &#039;, &#039; + kernel[ i * 3 + 3 ] + &#039;);&#039; );
            }
            kernelglsl = kernelglsl.join( &#039;\n&#039; );

            //var ssaoRadiusMin = this._sceneRadius * 0.002;
            //var ssaoRadiusMax = this._sceneRadius * 0.05;
            //var ssaoRadiusStep = ( ssaoRadiusMax - ssaoRadiusMin ) / 200.0;

            var fragmentshader = [
                &#039;&#039;,
                Composer.Filter.defaultFragmentShaderHeader,
                &#039;uniform sampler2D Texture1;&#039;,
                &#039;uniform sampler2D Texture2;&#039;,
                &#039;uniform mat4 projection;&#039;,
                &#039;uniform vec2 noiseSampling;&#039;,
                &#039;uniform float Power;&#039;, //&#039;+ &#039;{ &#039;min&#039;: 0.1, &#039;max&#039;: 16.0, &#039;step&#039;: 0.1, &#039;value&#039;: 1.0 }&#039;,
                &#039;uniform float Radius;&#039;, //&#039;+ &#039;{ &#039;min&#039;: &#039; + ssaoRadiusMin +&#039;, &#039;max&#039;: &#039; + ssaoRadiusMax + &#039;, &#039;step&#039;: &#039;+ ssaoRadiusStep + &#039;, &#039;value&#039;: 0.01 }&#039;,
                &#039;uniform float AngleLimit;&#039;,
                &#039;#define NB_SAMPLES &#039; + this._nbSamples,
                &#039;float depth;&#039;,
                &#039;vec3 normal;&#039;,
                &#039;vec4 position;&#039;,
                &#039;vec4 kernel[&#039; + nbSamples + &#039;];&#039;,


                &#039;mat3 computeBasis()&#039;,
                &#039;{&#039;,
                &#039;  vec2 uvrand = FragTexCoord0*noiseSampling;&#039;,
                &#039;  vec3 rvec = texture2D(Texture2, uvrand*2.0).xyz*2.0-vec3(1.0);&#039;,
                &#039;  vec3 tangent = normalize(rvec - normal * dot(rvec, normal));&#039;,
                &#039;  vec3 bitangent = cross(normal, tangent);&#039;,
                &#039;  mat3 tbn = mat3(tangent, bitangent, normal);&#039;,
                &#039;  return tbn;&#039;,
                &#039;}&#039;,

                &#039;void main (void)&#039;,
                &#039;{&#039;,
                kernelglsl,
                &#039;  position = texture2D(Texture1, FragTexCoord0);&#039;,
                &#039;  vec4 p = texture2D(Texture0, FragTexCoord0);&#039;,
                &#039;  depth = p.w;&#039;,
                &#039;  normal = vec3(p);&#039;,
                &#039;  if ( position.w == 0.0) {&#039;,
                &#039;     gl_FragColor = vec4(1.0,1.0,1.0,0.0);&#039;,
                &#039;     return;&#039;,
                &#039;  }&#039;,
                &#039;&#039;,
                &#039; mat3 tbn = computeBasis();&#039;,
                &#039; float occlusion = 0.0;&#039;,
                &#039; for (int i = 0; i &lt; NB_SAMPLES; i++) {&#039;,
                &#039;    vec3 vecKernel = vec3(kernel[i]);&#039;,
                &#039;    vecKernel[2] = max(AngleLimit,vecKernel[2]);&#039;,
                &#039;    vec3 sample = tbn * vecKernel;&#039;,
                &#039;    vec3 dir = sample;&#039;,
                &#039;    float w = dot(dir, normal);&#039;,
                &#039;    float dist = 1.0-kernel[i].w;&#039;,
                &#039;    w *= dist*dist*Power;&#039;,
                &#039;    sample = dir * float(Radius) + position.xyz;&#039;,

                &#039;    vec4 offset = projection * vec4(sample,1.0);&#039;,
                &#039;    offset.xy /= offset.w;&#039;,
                &#039;    offset.xy = offset.xy * 0.5 + 0.5;&#039;,

                &#039;    float sample_depth = texture2D(Texture1, offset.xy).z;&#039;,
                &#039;    float range_check = abs(sample.z - sample_depth) &lt; float(Radius) ? 1.0 : 0.0;&#039;,
                &#039;    occlusion += (sample_depth &gt; sample.z ? 1.0 : 0.0) * range_check*w;&#039;,

                &#039; }&#039;,
                &#039; occlusion = 1.0 - (occlusion / float(NB_SAMPLES));&#039;,
                &#039; gl_FragColor = vec4(vec3(occlusion),1.0);&#039;,
                &#039;}&#039;,
                &#039;&#039;
            ].join( &#039;\n&#039; );

            var program = new Program(
                new Shader( &#039;VERTEX_SHADER&#039;, vertexshader ),
                new Shader( &#039;FRAGMENT_SHADER&#039;, fragmentshader ) );

            stateSet.setAttributeAndModes( program );
            this._dirty = false;
        }
    } );



    Composer.Filter.SSAO8 = function ( options ) {
        Composer.Filter.SSAO.call( this, options );
    };

    Composer.Filter.SSAO8.prototype = MACROUTILS.objectInehrit( Composer.Filter.SSAO.prototype, {
        buildGeometry: function ( quad ) {
            quad.getAttributes().TexCoord1 = this._texCoord1;
            return quad;
        },
        build: function () {
            var stateSet = this._stateSet;
            var nbSamples = this._nbSamples;
            var kernel = new Array( nbSamples * 4 );
            //var angleLimit = this._angleLimit;
            ( function ( array ) {
                for ( var i = 0; i &lt; nbSamples; i++ ) {
                    var x, y, z;
                    x = 2.0 * ( Math.random() - 0.5 );
                    y = 2.0 * ( Math.random() - 0.5 );
                    z = Math.random();

                    var v = Vec3.normalize( [ x, y, z ], [] );
                    var scale = Math.max( i / nbSamples, 0.1 );
                    scale = 0.1 + ( 1.0 - 0.1 ) * ( scale * scale );
                    array[ i * 3 + 0 ] = v[ 0 ];
                    array[ i * 3 + 1 ] = v[ 1 ];
                    array[ i * 3 + 2 ] = v[ 2 ];
                    array[ i * 3 + 3 ] = scale;
                }
            } )( kernel );

            //var sizeNoise = this._noiseTextureSize;
            stateSet.setTextureAttributeAndModes( 2, this._noiseTexture );
            var uniform = stateSet.getUniform( &#039;noiseSampling&#039; );
            if ( uniform === undefined ) {
                uniform = Uniform.createFloat2( [ this._size[ 0 ] / this._noiseTextureSize, this._size[ 1 ] / this._noiseTextureSize ], &#039;noiseSampling&#039; );
                stateSet.addUniform( uniform );
            } else {
                uniform.set( [ this._size[ 0 ] / this._noiseTextureSize, this._size[ 1 ] / this._noiseTextureSize ] );
                uniform.dirty();
            }
            var vertexshader = [
                &#039;&#039;,
                &#039;#ifdef GL_ES&#039;,
                &#039;precision highp float;&#039;,
                &#039;#endif&#039;,
                &#039;attribute vec3 Vertex;&#039;,
                &#039;attribute vec2 TexCoord0;&#039;,
                &#039;attribute vec3 TexCoord1;&#039;,
                &#039;varying vec2 FragTexCoord0;&#039;,
                &#039;varying vec3 FragTexCoord1;&#039;,
                &#039;uniform mat4 ModelViewMatrix;&#039;,
                &#039;uniform mat4 ProjectionMatrix;&#039;,
                &#039;void main(void) {&#039;,
                &#039;  gl_Position = ProjectionMatrix * ModelViewMatrix * vec4(Vertex,1.0);&#039;,
                &#039;  FragTexCoord0 = TexCoord0;&#039;,
                &#039;  FragTexCoord1 = TexCoord1;&#039;,
                &#039;}&#039;,
                &#039;&#039;
            ].join( &#039;\n&#039; );

            var kernelglsl = [];
            for ( var i = 0; i &lt; nbSamples; i++ ) {
                kernelglsl.push( &#039;kernel[&#039; + i + &#039;] = vec4(&#039; + kernel[ i * 3 ] + &#039;,&#039; + kernel[ i * 3 + 1 ] + &#039;, &#039; + kernel[ i * 3 + 2 ] + &#039;, &#039; + kernel[ i * 3 + 3 ] + &#039;);&#039; );
            }
            kernelglsl = kernelglsl.join( &#039;\n&#039; );

            //var ssaoRadiusMin = this._sceneRadius * 0.002;
            //var ssaoRadiusMax = this._sceneRadius * 0.05;
            //var ssaoRadiusStep = ( ssaoRadiusMax - ssaoRadiusMin ) / 200.0;

            var fragmentshader = [
                &#039;&#039;,
                Composer.Filter.defaultFragmentShaderHeader,
                &#039;varying vec3 FragTexCoord1;&#039;,
                &#039;uniform sampler2D Texture1;&#039;,
                &#039;uniform sampler2D Texture2;&#039;,
                &#039;uniform mat4 projection;&#039;,
                &#039;uniform vec2 noiseSampling;&#039;,
                &#039;uniform float Power;&#039;, //&#039;+ &#039;{ &#039;min&#039;: 0.1, &#039;max&#039;: 16.0, &#039;step&#039;: 0.1, &#039;value&#039;: 1.0 }&#039;,
                &#039;uniform float Radius;&#039;, //&#039;+ &#039;{ &#039;min&#039;: &#039; + ssaoRadiusMin +&#039;, &#039;max&#039;: &#039; + ssaoRadiusMax + &#039;, &#039;step&#039;: &#039;+ ssaoRadiusStep + &#039;, &#039;value&#039;: 0.01 }&#039;,
                &#039;uniform float AngleLimit;&#039;,
                &#039;#define NB_SAMPLES &#039; + this._nbSamples,
                &#039;float depth;&#039;,
                &#039;float znear, zfar, zrange;&#039;,
                &#039;vec3 normal;&#039;,
                &#039;vec3 position;&#039;,
                &#039;vec4 kernel[&#039; + nbSamples + &#039;];&#039;,

                Composer.Filter.shaderUtils,

                &#039;mat3 computeBasis()&#039;,
                &#039;{&#039;,
                &#039;  vec2 uvrand = FragTexCoord0*noiseSampling;&#039;,
                &#039;  //uvrand = rand(gl_FragCoord.xy);&#039;,
                &#039;  vec3 rvec = texture2D(Texture2, uvrand*2.0).xyz*2.0-vec3(1.0);&#039;,
                &#039;  //vec3 rvec = normalize(vec3(uvrand,0.0));&#039;,
                &#039;  vec3 tangent = normalize(rvec - normal * dot(rvec, normal));&#039;,
                &#039;  vec3 bitangent = cross(normal, tangent);&#039;,
                &#039;  mat3 tbn = mat3(tangent, bitangent, normal);&#039;,
                &#039;  return tbn;&#039;,
                &#039;}&#039;,

                &#039;float getDepthValue(vec4 v) {&#039;,
                &#039;  float depth = unpack4x8ToFloat(v);&#039;,
                &#039;  depth = depth*zrange+znear;&#039;,
                &#039;  //depth = depth*zrange;&#039;,
                &#039;  return -depth;&#039;,
                &#039;}&#039;,

                &#039;void main (void)&#039;,
                &#039;{&#039;,
                kernelglsl,
                &#039;  vec4 p = texture2D(Texture0, FragTexCoord0);&#039;,
                &#039;  if (dot(p,p) &lt; 0.001) { &#039;,
                &#039;     gl_FragColor = vec4(1.0,1.0,1.0,0.0);&#039;,
                &#039;     return;&#039;,
                &#039;  }&#039;,
                &#039;  znear = projection[3][2] / (projection[2][2]-1.0);&#039;,
                &#039;  zfar = projection[3][2] / (projection[2][2]+1.0);&#039;,
                &#039;  zrange = zfar-znear;&#039;,
                &#039;  depth = getDepthValue(texture2D(Texture1, FragTexCoord0));&#039;,
                //B = (A - znear)/(zfar-znear);&#039;,
                //B = A/(zfar-znear) - znear/(zfar-znear);&#039;,
                //B+ znear/(zfar-znear) = A/(zfar-znear) ;&#039;,
                //(zfar-znear)*(B+ znear/(zfar-znear)) = A ;&#039;,
                //(zfar-znear)*B+ znear = A ;&#039;,

                &#039;  if ( -depth &lt; znear) {&#039;,
                &#039;     gl_FragColor = vec4(1.0,1.0,1.0,0.0);&#039;,
                &#039;     return;&#039;,
                &#039;  }&#039;,

                &#039;  normal = decodeNormal(unpack4x8To2Float(p));&#039;,

                &#039;  position = -FragTexCoord1*depth;&#039;,
                &#039;  position.z = -position.z;&#039;,

                &#039;&#039;,
                &#039; mat3 tbn = computeBasis();&#039;,
                &#039; float occlusion = 0.0;&#039;,
                &#039; for (int i = 0; i &lt; NB_SAMPLES; i++) {&#039;,
                &#039;    vec3 vecKernel = vec3(kernel[i]);&#039;,
                &#039;    vecKernel[2] = max(AngleLimit,vecKernel[2]);&#039;,
                &#039;    vec3 sample = tbn * vec3(vecKernel);&#039;,
                &#039;    vec3 dir = sample;&#039;,
                &#039;    float w = dot(dir, normal);&#039;,
                &#039;    float dist = 1.0-kernel[i].w;&#039;,
                &#039;    w *= dist*dist*Power;&#039;,
                &#039;    sample = dir * float(Radius) + position.xyz;&#039;,

                &#039;    vec4 offset = projection * vec4(sample,1.0);&#039;,
                &#039;    offset.xy /= offset.w;&#039;,
                &#039;    offset.xy = offset.xy * 0.5 + 0.5;&#039;,

                &#039;    float sample_depth = getDepthValue(texture2D(Texture1, offset.xy));&#039;,
                &#039;    float range_check = abs(sample.z - sample_depth) &lt; float(Radius) ? 1.0 : 0.0;&#039;,
                &#039;    occlusion += (sample_depth &gt; sample.z ? 1.0 : 0.0) * range_check*w;&#039;,

                &#039; }&#039;,
                &#039; occlusion = 1.0 - (occlusion / float(NB_SAMPLES));&#039;,
                &#039; gl_FragColor = vec4(vec3(occlusion),1.0);&#039;,
                &#039;}&#039;,
                &#039;&#039;
            ].join( &#039;\n&#039; );

            var program = new Program(
                new Shader( &#039;VERTEX_SHADER&#039;, vertexshader ),
                new Shader( &#039;FRAGMENT_SHADER&#039;, fragmentshader ) );

            stateSet.setAttributeAndModes( program );
            this._dirty = false;
        }
    } );

    return Composer;
} );</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
