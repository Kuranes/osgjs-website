<!DOCTYPE html>

<html>
<head>
  <title>KdTree.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>KdTree.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>define( [
    <span class="hljs-string">'osg/Utils'</span>,
    <span class="hljs-string">'osg/BoundingBox'</span>,
    <span class="hljs-string">'osg/Vec3'</span>,
    <span class="hljs-string">'osg/TriangleIndexFunctor'</span>,
    <span class="hljs-string">'osgUtil/TriangleIntersect'</span>,
    <span class="hljs-string">'osg/PrimitiveSet'</span>
], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( MACROUTILS, BoundingBox, Vec3, TriangleIndexFunctor, TriangleIntersect, PrimitiveSet )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p><strong><strong> GENERAL INFO ON KDTREE </strong></strong>
A KdTree is a Spatial Partitionning Tree (<a href="http://en.wikipedia.org/wiki/Space_partitioning">http://en.wikipedia.org/wiki/Space_partitioning</a>)
The type of tree is sort of defined by the splitting axis method:</p>
<ul>
<li>Per Axis split (octree/ kdtree)</li>
<li>Arbritrary direction split (bsp)</li>
</ul>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>The algorithm used for splitting, the name for finding best split is ‘Surface Area Heuristic (SAH)’
Octree divide the space in 8 subspace (one box -&gt; 8 sub boxes)
whereas kdtree does it by splitting population number in two equal group</p>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Kd Tree <a href="http://en.wikipedia.org/wiki/K-d_tree">http://en.wikipedia.org/wiki/K-d_tree</a>
a given set of points is sorted along one Axis (e.g. X).
The sorted list is split at the median.
The result are two sets, one for each half-space (left and right).</p>

            </div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Then, for the current node, the splitting-plane position (or the median-point) and depth is saved.
Finally, if the point-set has more than n point and the tree depth is below m 
(with n,m chosen by the user, as build options), two child-nodes (L/R one for each point-set) 
are created which themselfs repeat the pocedure.</p>

            </div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>The split-axis gets alternated at each depth, the split order is computed by checking the main
bounding box the length of its axis
<strong><strong> GENERAL INFO ON KDTREE </strong></strong></p>

            </div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>The KdTree implemented here is flattened, ie, a node and its children all lie in the same array
The most important thing is the understanding of the variables first and second for each node
Their semantic depend if the node is a leaf or not
if it’s a leaf :
  first and second defines a range in the triangles array (triangles in the cell)
if it’s not a leaf :</p>
<ul>
<li>first and second respectively represents the left and right sub children
We know that a node is a leaf if first is negative, in that case the range will be defined by
[ -first - 1, -first-1 + second ]</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> KdNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( first, second )</span> {</span>
        <span class="hljs-keyword">this</span>._bb = <span class="hljs-keyword">new</span> BoundingBox();
        <span class="hljs-keyword">this</span>._first = first;
        <span class="hljs-keyword">this</span>._second = second;</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>These variables represent the local clipped ray (for intersection test)
They are mostly temporary because they are recomputed for each intersection test</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>._nodeRayStart = [ <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span> ];
        <span class="hljs-keyword">this</span>._nodeRayEnd = [ <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span> ];
    };

    <span class="hljs-keyword">var</span> IntersectKdTree = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( vertices, nodes, triangles, intersections, start, end, nodePath )</span> {</span>
        <span class="hljs-keyword">this</span>._vertices = vertices;
        <span class="hljs-keyword">this</span>._kdNodes = nodes;
        <span class="hljs-keyword">this</span>._triangles = triangles;
        <span class="hljs-keyword">this</span>._intersector = <span class="hljs-keyword">new</span> TriangleIntersect();
        <span class="hljs-keyword">this</span>._dinvX = [ <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span> ];
        <span class="hljs-keyword">this</span>._dinvY = [ <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span> ];
        <span class="hljs-keyword">this</span>._dinvZ = [ <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span> ];
        <span class="hljs-keyword">this</span>.init( intersections, start, end, nodePath );
    };

    IntersectKdTree.prototype = {
        init: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( intersections, start, end, nodePath )</span> {</span>
            <span class="hljs-keyword">var</span> d = Vec3.sub( end, start, [ <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span> ] );
            <span class="hljs-keyword">var</span> len = Vec3.length( d );
            <span class="hljs-keyword">var</span> invLen = <span class="hljs-number">0.0</span>;
            <span class="hljs-keyword">if</span> ( len !== <span class="hljs-number">0.0</span> )
                invLen = <span class="hljs-number">1.0</span> / len;
            Vec3.mult( d, invLen, d );
            <span class="hljs-keyword">if</span> ( d[ <span class="hljs-number">0</span> ] !== <span class="hljs-number">0.0</span> ) Vec3.mult( d, <span class="hljs-number">1.0</span> / d[ <span class="hljs-number">0</span> ], <span class="hljs-keyword">this</span>._dinvX );
            <span class="hljs-keyword">if</span> ( d[ <span class="hljs-number">1</span> ] !== <span class="hljs-number">0.0</span> ) Vec3.mult( d, <span class="hljs-number">1.0</span> / d[ <span class="hljs-number">1</span> ], <span class="hljs-keyword">this</span>._dinvY );
            <span class="hljs-keyword">if</span> ( d[ <span class="hljs-number">2</span> ] !== <span class="hljs-number">0.0</span> ) Vec3.mult( d, <span class="hljs-number">1.0</span> / d[ <span class="hljs-number">2</span> ], <span class="hljs-keyword">this</span>._dinvZ );

            <span class="hljs-keyword">this</span>._intersector.hits = intersections;
            <span class="hljs-keyword">this</span>._intersector.setNodePath( nodePath );
            <span class="hljs-keyword">this</span>._intersector.set( start, end );
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Classic ray intersection test
If it’s a leaf it does ray-triangles intersection with the triangles in the cell
If it’s not a leaf, it descend in the tree in a recursive way as long as the ray
intersects the boundinbox of the nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        intersect: ( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

            <span class="hljs-keyword">var</span> v0 = [ <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span> ];
            <span class="hljs-keyword">var</span> v1 = [ <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span> ];
            <span class="hljs-keyword">var</span> v2 = [ <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span> ];

            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( node, ls, le )</span> {</span>
                <span class="hljs-keyword">var</span> first = node._first;
                <span class="hljs-keyword">var</span> second = node._second;
                <span class="hljs-keyword">var</span> triangles = <span class="hljs-keyword">this</span>._triangles;
                <span class="hljs-keyword">var</span> vertices = <span class="hljs-keyword">this</span>._vertices;

                <span class="hljs-keyword">if</span> ( first &lt; <span class="hljs-number">0</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>treat as a leaf</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="hljs-keyword">var</span> istart = -first - <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">var</span> iend = istart + second;
                    <span class="hljs-keyword">var</span> intersector = <span class="hljs-keyword">this</span>._intersector;
                    intersector.index = istart;

                    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = istart; i &lt; iend; ++i ) {
                        <span class="hljs-keyword">var</span> id = i * <span class="hljs-number">3</span>;
                        <span class="hljs-keyword">var</span> iv0 = triangles[ id ] * <span class="hljs-number">3</span>;
                        <span class="hljs-keyword">var</span> iv1 = triangles[ id + <span class="hljs-number">1</span> ] * <span class="hljs-number">3</span>;
                        <span class="hljs-keyword">var</span> iv2 = triangles[ id + <span class="hljs-number">2</span> ] * <span class="hljs-number">3</span>;

                        v0[ <span class="hljs-number">0</span> ] = vertices[ iv0 ];
                        v0[ <span class="hljs-number">1</span> ] = vertices[ iv0 + <span class="hljs-number">1</span> ];
                        v0[ <span class="hljs-number">2</span> ] = vertices[ iv0 + <span class="hljs-number">2</span> ];

                        v1[ <span class="hljs-number">0</span> ] = vertices[ iv1 ];
                        v1[ <span class="hljs-number">1</span> ] = vertices[ iv1 + <span class="hljs-number">1</span> ];
                        v1[ <span class="hljs-number">2</span> ] = vertices[ iv1 + <span class="hljs-number">2</span> ];

                        v2[ <span class="hljs-number">0</span> ] = vertices[ iv2 ];
                        v2[ <span class="hljs-number">1</span> ] = vertices[ iv2 + <span class="hljs-number">1</span> ];
                        v2[ <span class="hljs-number">2</span> ] = vertices[ iv2 + <span class="hljs-number">2</span> ];

                        intersector.intersect( v0, v1, v2 );
                    }
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">var</span> s = node._nodeRayStart;
                    <span class="hljs-keyword">var</span> e = node._nodeRayEnd;
                    Vec3.copy( ls, s );
                    Vec3.copy( le, e );
                    <span class="hljs-keyword">if</span> ( first &gt; <span class="hljs-number">0</span> ) {
                        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.intersectAndClip( s, e, <span class="hljs-keyword">this</span>._kdNodes[ first ]._bb ) ) {
                            <span class="hljs-keyword">this</span>.intersect( <span class="hljs-keyword">this</span>._kdNodes[ first ], s, e );
                        }
                    }
                    <span class="hljs-keyword">if</span> ( second &gt; <span class="hljs-number">0</span> ) {
                        Vec3.copy( ls, s );
                        Vec3.copy( le, e );
                        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.intersectAndClip( s, e, <span class="hljs-keyword">this</span>._kdNodes[ second ]._bb ) ) {
                            <span class="hljs-keyword">this</span>.intersect( <span class="hljs-keyword">this</span>._kdNodes[ second ], s, e );
                        }
                    }
                }
            };
        } )(),</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>This method do 2 things
It test if the ray intersects the node
If so… it clip the ray so that the start and end point of the ray are
snapped to the bounding box of the nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        intersectAndClip: ( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
            <span class="hljs-keyword">var</span> tmp = [ <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span> ];
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( s, e, bb )</span> {</span>
                <span class="hljs-keyword">var</span> min = bb._min;
                <span class="hljs-keyword">var</span> xmin = min[ <span class="hljs-number">0</span> ];
                <span class="hljs-keyword">var</span> ymin = min[ <span class="hljs-number">1</span> ];
                <span class="hljs-keyword">var</span> zmin = min[ <span class="hljs-number">2</span> ];

                <span class="hljs-keyword">var</span> max = bb._max;
                <span class="hljs-keyword">var</span> xmax = max[ <span class="hljs-number">0</span> ];
                <span class="hljs-keyword">var</span> ymax = max[ <span class="hljs-number">1</span> ];
                <span class="hljs-keyword">var</span> zmax = max[ <span class="hljs-number">2</span> ];

                <span class="hljs-keyword">var</span> invX = <span class="hljs-keyword">this</span>._dinvX;
                <span class="hljs-keyword">var</span> invY = <span class="hljs-keyword">this</span>._dinvY;
                <span class="hljs-keyword">var</span> invZ = <span class="hljs-keyword">this</span>._dinvZ;

                <span class="hljs-keyword">if</span> ( s[ <span class="hljs-number">0</span> ] &lt;= e[ <span class="hljs-number">0</span> ] ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>trivial reject of segment wholely outside.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="hljs-keyword">if</span> ( e[ <span class="hljs-number">0</span> ] &lt; xmin ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    <span class="hljs-keyword">if</span> ( s[ <span class="hljs-number">0</span> ] &gt; xmax ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

                    <span class="hljs-keyword">if</span> ( s[ <span class="hljs-number">0</span> ] &lt; xmin ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>clip s to xMin.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        Vec3.mult( invX, xmin - s[ <span class="hljs-number">0</span> ], tmp );
                        Vec3.add( s, tmp, s );
                    }

                    <span class="hljs-keyword">if</span> ( e[ <span class="hljs-number">0</span> ] &gt; xmax ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>clip e to xMax.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        Vec3.mult( invX, xmax - s[ <span class="hljs-number">0</span> ], tmp );
                        Vec3.add( s, tmp, e );
                    }
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">if</span> ( s[ <span class="hljs-number">0</span> ] &lt; xmin ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    <span class="hljs-keyword">if</span> ( e[ <span class="hljs-number">0</span> ] &gt; xmax ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

                    <span class="hljs-keyword">if</span> ( e[ <span class="hljs-number">0</span> ] &lt; xmin ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>clip s to xMin.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        Vec3.mult( invX, xmin - s[ <span class="hljs-number">0</span> ], tmp );
                        Vec3.add( s, tmp, e );
                    }

                    <span class="hljs-keyword">if</span> ( s[ <span class="hljs-number">0</span> ] &gt; xmax ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>clip e to xMax.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        Vec3.mult( invX, xmax - s[ <span class="hljs-number">0</span> ], tmp );
                        Vec3.add( s, tmp, s );
                    }
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>compate s and e against the yMin to yMax range of bb.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> ( s[ <span class="hljs-number">1</span> ] &lt;= e[ <span class="hljs-number">1</span> ] ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>trivial reject of segment wholely outside.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="hljs-keyword">if</span> ( e[ <span class="hljs-number">1</span> ] &lt; ymin ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    <span class="hljs-keyword">if</span> ( s[ <span class="hljs-number">1</span> ] &gt; ymax ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

                    <span class="hljs-keyword">if</span> ( s[ <span class="hljs-number">1</span> ] &lt; ymin ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>clip s to yMin.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        Vec3.mult( invY, ymin - s[ <span class="hljs-number">1</span> ], tmp );
                        Vec3.add( s, tmp, s );
                    }

                    <span class="hljs-keyword">if</span> ( e[ <span class="hljs-number">1</span> ] &gt; ymax ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>clip e to yMax.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        Vec3.mult( invY, ymax - s[ <span class="hljs-number">1</span> ], tmp );
                        Vec3.add( s, tmp, e );
                    }
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">if</span> ( s[ <span class="hljs-number">1</span> ] &lt; ymin ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    <span class="hljs-keyword">if</span> ( e[ <span class="hljs-number">1</span> ] &gt; ymax ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

                    <span class="hljs-keyword">if</span> ( e[ <span class="hljs-number">1</span> ] &lt; ymin ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>clip s to yMin.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        Vec3.mult( invY, ymin - s[ <span class="hljs-number">1</span> ], tmp );
                        Vec3.add( s, tmp, e );
                    }

                    <span class="hljs-keyword">if</span> ( s[ <span class="hljs-number">1</span> ] &gt; ymax ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>clip e to yMax.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        Vec3.mult( invY, ymax - s[ <span class="hljs-number">1</span> ], tmp );
                        Vec3.add( s, tmp, s );
                    }
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>compate s and e against the zMin to zMax range of bb.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> ( s[ <span class="hljs-number">2</span> ] &lt;= e[ <span class="hljs-number">2</span> ] ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>trivial reject of segment wholely outside.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="hljs-keyword">if</span> ( e[ <span class="hljs-number">2</span> ] &lt; zmin ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    <span class="hljs-keyword">if</span> ( s[ <span class="hljs-number">2</span> ] &gt; zmax ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

                    <span class="hljs-keyword">if</span> ( s[ <span class="hljs-number">2</span> ] &lt; zmin ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>clip s to zMin.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        Vec3.mult( invZ, zmin - s[ <span class="hljs-number">2</span> ], tmp );
                        Vec3.add( s, tmp, s );
                    }

                    <span class="hljs-keyword">if</span> ( e[ <span class="hljs-number">2</span> ] &gt; zmax ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>clip e to zMax.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        Vec3.mult( invZ, zmax - s[ <span class="hljs-number">2</span> ], tmp );
                        Vec3.add( s, tmp, e );
                    }
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">if</span> ( s[ <span class="hljs-number">2</span> ] &lt; zmin ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    <span class="hljs-keyword">if</span> ( e[ <span class="hljs-number">2</span> ] &gt; zmax ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

                    <span class="hljs-keyword">if</span> ( e[ <span class="hljs-number">2</span> ] &lt; zmin ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>clip s to zMin.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        Vec3.mult( invZ, zmin - s[ <span class="hljs-number">2</span> ], tmp );
                        Vec3.add( s, tmp, e );
                    }

                    <span class="hljs-keyword">if</span> ( s[ <span class="hljs-number">2</span> ] &gt; zmax ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>clip e to zMax.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        Vec3.mult( invZ, zmax - s[ <span class="hljs-number">2</span> ], tmp );
                        Vec3.add( s, tmp, s );
                    }
                }
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            };
        } )()
    };

    <span class="hljs-keyword">var</span> BuildKdTree = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( kdTree )</span> {</span>
        <span class="hljs-keyword">this</span>._kdTree = kdTree;
        <span class="hljs-keyword">this</span>._bb = <span class="hljs-keyword">new</span> BoundingBox();
        <span class="hljs-keyword">this</span>._primitiveIndices = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Uint32Array</span>
        <span class="hljs-keyword">this</span>._centers = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Float32Array</span>
        <span class="hljs-keyword">this</span>._axisOrder = [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ];
        <span class="hljs-keyword">this</span>._stackLength = <span class="hljs-number">0</span>;
    };

    BuildKdTree.prototype = {
        build: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( options, geom )</span> {</span>
            <span class="hljs-keyword">var</span> targetTris = options._targetNumTrianglesPerLeaf;
            <span class="hljs-keyword">var</span> vertexAttrib = geom.getVertexAttributeList().Vertex;
            <span class="hljs-keyword">if</span> ( !vertexAttrib )
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">var</span> vertices = vertexAttrib.getElements();
            <span class="hljs-keyword">if</span> ( !vertices )
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">var</span> nbVertices = vertices.length / <span class="hljs-number">3</span>;
            <span class="hljs-keyword">if</span> ( nbVertices &lt; targetTris )
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

            <span class="hljs-keyword">this</span>._bb.copy( geom.getBoundingBox() );
            <span class="hljs-keyword">this</span>._kdTree.setVertices( vertices );

            <span class="hljs-keyword">this</span>.computeDivisions( options );
            options._numVerticesProcessed += nbVertices;

            <span class="hljs-keyword">this</span>.computeTriangles( geom );

            <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">new</span> KdNode( -<span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>._primitiveIndices.length );
            node._bb.copy( <span class="hljs-keyword">this</span>._bb );
            <span class="hljs-keyword">var</span> nodeNum = <span class="hljs-keyword">this</span>._kdTree.addNode( node );

            <span class="hljs-keyword">var</span> bb = <span class="hljs-keyword">new</span> BoundingBox();
            bb.copy( <span class="hljs-keyword">this</span>._bb );
            nodeNum = <span class="hljs-keyword">this</span>.divide( options, bb, nodeNum, <span class="hljs-number">0</span> );</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Here we re-order the triangle list so that we can have a flat tree
_primitiveIndices is the ordered array of the triangle indices</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> triangles = <span class="hljs-keyword">this</span>._kdTree.getTriangles();
            <span class="hljs-keyword">var</span> primitives = <span class="hljs-keyword">this</span>._primitiveIndices;
            <span class="hljs-keyword">var</span> nbPrimitives = primitives.length;
            <span class="hljs-keyword">var</span> triangleOrdered = <span class="hljs-keyword">new</span> MACROUTILS.Uint32Array( triangles.length );
            <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; nbPrimitives; ++i, j += <span class="hljs-number">3</span> ) {
                <span class="hljs-keyword">var</span> id = primitives[ i ] * <span class="hljs-number">3</span>;
                triangleOrdered[ j ] = triangles[ id ];
                triangleOrdered[ j + <span class="hljs-number">1</span> ] = triangles[ id + <span class="hljs-number">1</span> ];
                triangleOrdered[ j + <span class="hljs-number">2</span> ] = triangles[ id + <span class="hljs-number">2</span> ];
            }
            <span class="hljs-keyword">this</span>._kdTree.setTriangles( triangleOrdered );

            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._kdTree.getNodes().length &gt; <span class="hljs-number">0</span>;
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>The function first gather all the triangles of the geometry
It then computes the centroid for each triangle and initialize
of triangles indices that will refer to the main triangles array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        computeTriangles: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( geom )</span> {</span>
            <span class="hljs-keyword">var</span> kdTree = <span class="hljs-keyword">this</span>._kdTree;

            <span class="hljs-keyword">var</span> totalLenArray = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">var</span> geomPrimitives = geom.primitives;
            <span class="hljs-keyword">var</span> nbPrimitives = geomPrimitives.length;
            <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; nbPrimitives; i++ ) {
                <span class="hljs-keyword">var</span> prim = geomPrimitives[ i ];
                <span class="hljs-keyword">var</span> mode = prim.getMode();
                <span class="hljs-keyword">if</span> ( mode === PrimitiveSet.TRIANGLES )
                    totalLenArray += prim.getCount();
                <span class="hljs-keyword">else</span>
                    totalLenArray += ( prim.getCount() - <span class="hljs-number">2</span> ) * <span class="hljs-number">3</span>;
            }
            <span class="hljs-keyword">var</span> indices = <span class="hljs-keyword">new</span> MACROUTILS.Uint32Array( totalLenArray );
            <span class="hljs-keyword">var</span> next = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">var</span> cb = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( i1, i2, i3 )</span> {</span>
                <span class="hljs-keyword">if</span> ( i1 === i2 || i1 === i3 || i2 === i3 )
                    <span class="hljs-keyword">return</span>;
                indices[ next ] = i1;
                indices[ next + <span class="hljs-number">1</span> ] = i2;
                indices[ next + <span class="hljs-number">2</span> ] = i3;
                next += <span class="hljs-number">3</span>;
            };

            <span class="hljs-keyword">var</span> tif = <span class="hljs-keyword">new</span> TriangleIndexFunctor( geom, cb );
            tif.apply();
            indices = indices.subarray( <span class="hljs-number">0</span>, next );

            <span class="hljs-keyword">var</span> nbTriangles = indices.length;
            kdTree.setTriangles( indices );

            <span class="hljs-keyword">var</span> vertices = kdTree.getVertices();

            <span class="hljs-keyword">this</span>._centers = <span class="hljs-keyword">new</span> MACROUTILS.Float32Array( nbTriangles );
            <span class="hljs-keyword">var</span> centers = <span class="hljs-keyword">this</span>._centers;
            <span class="hljs-keyword">this</span>._primitiveIndices = <span class="hljs-keyword">new</span> MACROUTILS.Uint32Array( nbTriangles / <span class="hljs-number">3</span> );
            <span class="hljs-keyword">var</span> primitives = <span class="hljs-keyword">this</span>._primitiveIndices;

            <span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; nbTriangles; i += <span class="hljs-number">3</span>, ++j ) {
                <span class="hljs-keyword">var</span> iv0 = indices[ i ];
                <span class="hljs-keyword">var</span> iv1 = indices[ i + <span class="hljs-number">1</span> ];
                <span class="hljs-keyword">var</span> iv2 = indices[ i + <span class="hljs-number">2</span> ];</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>discard degenerate points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> ( iv0 === iv1 || iv1 === iv2 || iv0 === iv2 )
                    <span class="hljs-keyword">return</span>;

                iv0 *= <span class="hljs-number">3</span>;
                iv1 *= <span class="hljs-number">3</span>;
                iv2 *= <span class="hljs-number">3</span>;

                <span class="hljs-keyword">var</span> v0x = vertices[ iv0 ];
                <span class="hljs-keyword">var</span> v0y = vertices[ iv0 + <span class="hljs-number">1</span> ];
                <span class="hljs-keyword">var</span> v0z = vertices[ iv0 + <span class="hljs-number">2</span> ];

                <span class="hljs-keyword">var</span> v1x = vertices[ iv1 ];
                <span class="hljs-keyword">var</span> v1y = vertices[ iv1 + <span class="hljs-number">1</span> ];
                <span class="hljs-keyword">var</span> v1z = vertices[ iv1 + <span class="hljs-number">2</span> ];

                <span class="hljs-keyword">var</span> v2x = vertices[ iv2 ];
                <span class="hljs-keyword">var</span> v2y = vertices[ iv2 + <span class="hljs-number">1</span> ];
                <span class="hljs-keyword">var</span> v2z = vertices[ iv2 + <span class="hljs-number">2</span> ];

                <span class="hljs-keyword">var</span> minx = <span class="hljs-built_in">Math</span>.min( v0x, <span class="hljs-built_in">Math</span>.min( v1x, v2x ) );
                <span class="hljs-keyword">var</span> miny = <span class="hljs-built_in">Math</span>.min( v0y, <span class="hljs-built_in">Math</span>.min( v1y, v2y ) );
                <span class="hljs-keyword">var</span> minz = <span class="hljs-built_in">Math</span>.min( v0z, <span class="hljs-built_in">Math</span>.min( v1z, v2z ) );

                <span class="hljs-keyword">var</span> maxx = <span class="hljs-built_in">Math</span>.max( v0x, <span class="hljs-built_in">Math</span>.max( v1x, v2x ) );
                <span class="hljs-keyword">var</span> maxy = <span class="hljs-built_in">Math</span>.max( v0y, <span class="hljs-built_in">Math</span>.max( v1y, v2y ) );
                <span class="hljs-keyword">var</span> maxz = <span class="hljs-built_in">Math</span>.max( v0z, <span class="hljs-built_in">Math</span>.max( v1z, v2z ) );
                centers[ i ] = ( minx + maxx ) * <span class="hljs-number">0.5</span>;
                centers[ i + <span class="hljs-number">1</span> ] = ( miny + maxy ) * <span class="hljs-number">0.5</span>;
                centers[ i + <span class="hljs-number">2</span> ] = ( minz + maxz ) * <span class="hljs-number">0.5</span>;
                primitives[ j ] = j;
            }
        },
        computeDivisions: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( options )</span> {</span>
            <span class="hljs-keyword">this</span>._stackLength = options._maxNumLevels;
            <span class="hljs-keyword">var</span> max = <span class="hljs-keyword">this</span>._bb._max;
            <span class="hljs-keyword">var</span> min = <span class="hljs-keyword">this</span>._bb._min;
            <span class="hljs-keyword">var</span> dx = max[ <span class="hljs-number">0</span> ] - min[ <span class="hljs-number">0</span> ];
            <span class="hljs-keyword">var</span> dy = max[ <span class="hljs-number">1</span> ] - min[ <span class="hljs-number">1</span> ];
            <span class="hljs-keyword">var</span> dz = max[ <span class="hljs-number">2</span> ] - min[ <span class="hljs-number">2</span> ];
            <span class="hljs-keyword">var</span> axisOrder = <span class="hljs-keyword">this</span>._axisOrder;</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>We set the cutting order (longest edge aabb first)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            axisOrder[ <span class="hljs-number">0</span> ] = ( dx &gt;= dy &amp;&amp; dx &gt;= dz ) ? <span class="hljs-number">0</span> : ( dy &gt;= dz ) ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>;
            axisOrder[ <span class="hljs-number">2</span> ] = ( dx &lt; dy &amp;&amp; dx &lt; dz ) ? <span class="hljs-number">0</span> : ( dy &lt; dz ) ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>;
            <span class="hljs-keyword">var</span> sum = axisOrder[ <span class="hljs-number">0</span> ] + axisOrder[ <span class="hljs-number">2</span> ];
            axisOrder[ <span class="hljs-number">1</span> ] = sum === <span class="hljs-number">3</span> ? <span class="hljs-number">0</span> : sum === <span class="hljs-number">2</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>;
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>The core function of the kdtree building
It checks if the node need to be subdivide or not
If it decides it’s a leaf, it computes the final bounding box of the node
and it ends here
If it’s a node, then it puts the splitting axis position on the median population
On the same time it reorder the triangle index array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        divide: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( options, bb, nodeIndex, level )</span> {</span>
            <span class="hljs-keyword">var</span> kdTree = <span class="hljs-keyword">this</span>._kdTree;
            <span class="hljs-keyword">var</span> primitives = <span class="hljs-keyword">this</span>._primitiveIndices;
            <span class="hljs-keyword">var</span> nodes = kdTree.getNodes();
            <span class="hljs-keyword">var</span> node = nodes[ nodeIndex ];

            <span class="hljs-keyword">var</span> first = node._first;
            <span class="hljs-keyword">var</span> second = node._second;

            <span class="hljs-keyword">var</span> needToDivide = level &lt; <span class="hljs-keyword">this</span>._stackLength &amp;&amp; first &lt; <span class="hljs-number">0</span> &amp;&amp; second &gt; options._targetNumTrianglesPerLeaf;
            <span class="hljs-keyword">var</span> istart = -first - <span class="hljs-number">1</span>;
            <span class="hljs-keyword">var</span> iend = istart + second - <span class="hljs-number">1</span>;

            <span class="hljs-keyword">if</span> ( !needToDivide ) {
                <span class="hljs-keyword">if</span> ( first &lt; <span class="hljs-number">0</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>leaf is done, now compute bound on it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="hljs-keyword">this</span>.computeNodeBox( node, istart, iend );
                }
                <span class="hljs-keyword">return</span> nodeIndex;
            }

            <span class="hljs-keyword">if</span> ( first &gt;= <span class="hljs-number">0</span> )
                <span class="hljs-keyword">return</span> nodeIndex;</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>leaf node as first &lt; 0, so look at dividing it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
            <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>._axisOrder[ level % <span class="hljs-number">3</span> ];
            <span class="hljs-keyword">var</span> originalMin = bb._min[ axis ];
            <span class="hljs-keyword">var</span> originalMax = bb._max[ axis ];

            <span class="hljs-keyword">var</span> mid = ( originalMin + originalMax ) * <span class="hljs-number">0.5</span>;

            <span class="hljs-keyword">var</span> originalLeftChildIndex = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">var</span> originalRightChildIndex = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">var</span> insitueDivision = <span class="hljs-literal">false</span>;

            <span class="hljs-keyword">var</span> left = istart;
            <span class="hljs-keyword">var</span> right = iend;

            <span class="hljs-keyword">var</span> centers = <span class="hljs-keyword">this</span>._centers;
            <span class="hljs-keyword">while</span> ( left &lt; right ) {
                <span class="hljs-keyword">while</span> ( left &lt; right &amp;&amp; ( centers[ primitives[ left ] * <span class="hljs-number">3</span> + axis ] &lt;= mid ) ) {
                    ++left;
                }

                <span class="hljs-keyword">while</span> ( left &lt; right &amp;&amp; ( centers[ primitives[ right ] * <span class="hljs-number">3</span> + axis ] &gt; mid ) ) {
                    --right;
                }

                <span class="hljs-keyword">if</span> ( left &lt; right ) {
                    <span class="hljs-keyword">var</span> tmp = primitives[ left ];
                    primitives[ left ] = primitives[ right ];
                    primitives[ right ] = tmp;
                    ++left;
                    --right;
                }
            }

            <span class="hljs-keyword">if</span> ( left === right ) {
                <span class="hljs-keyword">if</span> ( centers[ primitives[ left ] * <span class="hljs-number">3</span> + axis ] &lt;= mid )++left;
                <span class="hljs-keyword">else</span> --right;
            }

            <span class="hljs-keyword">if</span> ( ( right - istart ) &lt;= -<span class="hljs-number">1</span> ) {
                originalLeftChildIndex = <span class="hljs-number">0</span>;
                originalRightChildIndex = nodeIndex;
                insitueDivision = <span class="hljs-literal">true</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( ( iend - left ) &lt;= -<span class="hljs-number">1</span> ) {
                originalLeftChildIndex = nodeIndex;
                originalRightChildIndex = <span class="hljs-number">0</span>;
                insitueDivision = <span class="hljs-literal">true</span>;
            } <span class="hljs-keyword">else</span> {
                originalLeftChildIndex = kdTree.addNode( <span class="hljs-keyword">new</span> KdNode( -istart - <span class="hljs-number">1</span>, ( right - istart ) + <span class="hljs-number">1</span> ) );
                originalRightChildIndex = kdTree.addNode( <span class="hljs-keyword">new</span> KdNode( -left - <span class="hljs-number">1</span>, ( iend - left ) + <span class="hljs-number">1</span> ) );
            }


            <span class="hljs-keyword">var</span> restore = bb._max[ axis ];
            bb._max[ axis ] = mid;

            <span class="hljs-keyword">var</span> leftChildIndex = originalLeftChildIndex !== <span class="hljs-number">0</span> ? <span class="hljs-keyword">this</span>.divide( options, bb, originalLeftChildIndex, level + <span class="hljs-number">1</span> ) : <span class="hljs-number">0</span>;

            bb._max[ axis ] = restore;

            restore = bb._min[ axis ];
            bb._min[ axis ] = mid;

            <span class="hljs-keyword">var</span> rightChildIndex = originalRightChildIndex !== <span class="hljs-number">0</span> ? <span class="hljs-keyword">this</span>.divide( options, bb, originalRightChildIndex, level + <span class="hljs-number">1</span> ) : <span class="hljs-number">0</span>;

            bb._min[ axis ] = restore;

            <span class="hljs-keyword">if</span> ( !insitueDivision ) {
                node._first = leftChildIndex;
                node._second = rightChildIndex;

                insitueDivision = <span class="hljs-literal">true</span>;

                <span class="hljs-keyword">var</span> bnode = node._bb;
                bnode.init();
                <span class="hljs-keyword">if</span> ( leftChildIndex !== <span class="hljs-number">0</span> ) bnode.expandByBoundingBox( nodes[ leftChildIndex ]._bb );
                <span class="hljs-keyword">if</span> ( rightChildIndex !== <span class="hljs-number">0</span> ) bnode.expandByBoundingBox( nodes[ rightChildIndex ]._bb );
            }
            <span class="hljs-keyword">return</span> nodeIndex;
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>It computes the bounding box of the node so that the box contains all the triangles
of the cell</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        computeNodeBox: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( node, istart, iend )</span> {</span>
            <span class="hljs-keyword">var</span> minx = <span class="hljs-literal">Infinity</span>,
                miny = <span class="hljs-literal">Infinity</span>,
                minz = <span class="hljs-literal">Infinity</span>,
                maxx = -<span class="hljs-literal">Infinity</span>,
                maxy = -<span class="hljs-literal">Infinity</span>,
                maxz = -<span class="hljs-literal">Infinity</span>;
            <span class="hljs-keyword">var</span> triangles = <span class="hljs-keyword">this</span>._kdTree.getTriangles();
            <span class="hljs-keyword">var</span> vertices = <span class="hljs-keyword">this</span>._kdTree.getVertices();
            <span class="hljs-keyword">var</span> primitives = <span class="hljs-keyword">this</span>._primitiveIndices;
            <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = istart; i &lt;= iend; ++i ) {
                <span class="hljs-keyword">var</span> id = primitives[ i ] * <span class="hljs-number">3</span>;
                <span class="hljs-keyword">var</span> iv0 = triangles[ id ] * <span class="hljs-number">3</span>;
                <span class="hljs-keyword">var</span> iv1 = triangles[ id + <span class="hljs-number">1</span> ] * <span class="hljs-number">3</span>;
                <span class="hljs-keyword">var</span> iv2 = triangles[ id + <span class="hljs-number">2</span> ] * <span class="hljs-number">3</span>;

                <span class="hljs-keyword">var</span> v0x = vertices[ iv0 ];
                <span class="hljs-keyword">var</span> v0y = vertices[ iv0 + <span class="hljs-number">1</span> ];
                <span class="hljs-keyword">var</span> v0z = vertices[ iv0 + <span class="hljs-number">2</span> ];

                <span class="hljs-keyword">var</span> v1x = vertices[ iv1 ];
                <span class="hljs-keyword">var</span> v1y = vertices[ iv1 + <span class="hljs-number">1</span> ];
                <span class="hljs-keyword">var</span> v1z = vertices[ iv1 + <span class="hljs-number">2</span> ];

                <span class="hljs-keyword">var</span> v2x = vertices[ iv2 ];
                <span class="hljs-keyword">var</span> v2y = vertices[ iv2 + <span class="hljs-number">1</span> ];
                <span class="hljs-keyword">var</span> v2z = vertices[ iv2 + <span class="hljs-number">2</span> ];

                minx = <span class="hljs-built_in">Math</span>.min( minx, <span class="hljs-built_in">Math</span>.min( v0x, <span class="hljs-built_in">Math</span>.min( v1x, v2x ) ) );
                miny = <span class="hljs-built_in">Math</span>.min( miny, <span class="hljs-built_in">Math</span>.min( v0y, <span class="hljs-built_in">Math</span>.min( v1y, v2y ) ) );
                minz = <span class="hljs-built_in">Math</span>.min( minz, <span class="hljs-built_in">Math</span>.min( v0z, <span class="hljs-built_in">Math</span>.min( v1z, v2z ) ) );

                maxx = <span class="hljs-built_in">Math</span>.max( maxx, <span class="hljs-built_in">Math</span>.max( v0x, <span class="hljs-built_in">Math</span>.max( v1x, v2x ) ) );
                maxy = <span class="hljs-built_in">Math</span>.max( maxy, <span class="hljs-built_in">Math</span>.max( v0y, <span class="hljs-built_in">Math</span>.max( v1y, v2y ) ) );
                maxz = <span class="hljs-built_in">Math</span>.max( maxz, <span class="hljs-built_in">Math</span>.max( v0z, <span class="hljs-built_in">Math</span>.max( v1z, v2z ) ) );
            }
            <span class="hljs-keyword">var</span> epsilon = <span class="hljs-number">1E-6</span>;
            <span class="hljs-keyword">var</span> bnode = node._bb;
            <span class="hljs-keyword">var</span> bmin = bnode._min;
            <span class="hljs-keyword">var</span> bmax = bnode._max;
            bmin[ <span class="hljs-number">0</span> ] = minx - epsilon;
            bmin[ <span class="hljs-number">1</span> ] = miny - epsilon;
            bmin[ <span class="hljs-number">2</span> ] = minz - epsilon;
            bmax[ <span class="hljs-number">0</span> ] = maxx + epsilon;
            bmax[ <span class="hljs-number">1</span> ] = maxy + epsilon;
            bmax[ <span class="hljs-number">2</span> ] = maxz + epsilon;
        }
    };

    <span class="hljs-keyword">var</span> KdTree = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">this</span>._vertices = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">this</span>._kdNodes = [];
        <span class="hljs-keyword">this</span>._triangles = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Float32Array</span>
    };

    KdTree.prototype = MACROUTILS.objectLibraryClass( {
        getVertices: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._vertices;
        },
        setVertices: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( vertices )</span> {</span>
            <span class="hljs-keyword">this</span>._vertices = vertices;
        },
        getNodes: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._kdNodes;
        },
        getTriangles: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._triangles;
        },
        setTriangles: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( triangles )</span> {</span>
            <span class="hljs-keyword">this</span>._triangles = triangles;
        },
        addNode: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( node )</span> {</span>
            <span class="hljs-keyword">this</span>._kdNodes.push( node );
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._kdNodes.length - <span class="hljs-number">1</span>;
        },
        build: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( options, geom )</span> {</span>
            <span class="hljs-keyword">var</span> buildTree = <span class="hljs-keyword">new</span> BuildKdTree( <span class="hljs-keyword">this</span> );
            <span class="hljs-keyword">return</span> buildTree.build( options, geom );
        },
        intersect: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( start, end, intersections, nodePath )</span> {</span>
            <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._kdNodes.length === <span class="hljs-number">0</span> ) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }

            <span class="hljs-keyword">var</span> numIntersectionsBefore = intersections.length;
            <span class="hljs-keyword">var</span> intersector = <span class="hljs-keyword">new</span> IntersectKdTree( <span class="hljs-keyword">this</span>._vertices, <span class="hljs-keyword">this</span>._kdNodes, <span class="hljs-keyword">this</span>._triangles, intersections, start, end, nodePath );
            intersector.intersect( <span class="hljs-keyword">this</span>.getNodes()[ <span class="hljs-number">0</span> ], start, end );

            <span class="hljs-keyword">return</span> numIntersectionsBefore !== intersections.length;
        }
    }, <span class="hljs-string">'osg'</span>, <span class="hljs-string">'KdTree'</span> );

    <span class="hljs-keyword">return</span> KdTree;
} );</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
